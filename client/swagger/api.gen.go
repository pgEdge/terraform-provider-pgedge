// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package client

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	AccessTokenScopes = "AccessToken.Scopes"
)

// Defines values for CreateClusterShareInputTenancy.
const (
	Allowlist CreateClusterShareInputTenancy = "allowlist"
	Same      CreateClusterShareInputTenancy = "same"
)

// Defines values for GetBackupRepositoryInfoParamsBackupType.
const (
	Diff GetBackupRepositoryInfoParamsBackupType = "diff"
	Full GetBackupRepositoryInfoParamsBackupType = "full"
	Incr GetBackupRepositoryInfoParamsBackupType = "incr"
)

// Defines values for ListClusterNodesParamsOrderBy.
const (
	Distance ListClusterNodesParamsOrderBy = "distance"
)

// Defines values for RotateDatabaseRolePasswordParamsRoleName.
const (
	Admin       RotateDatabaseRolePasswordParamsRoleName = "admin"
	App         RotateDatabaseRolePasswordParamsRoleName = "app"
	AppReadOnly RotateDatabaseRolePasswordParamsRoleName = "app_read_only"
)

// Defines values for ListTasksParamsStatus.
const (
	Failed    ListTasksParamsStatus = "failed"
	Queued    ListTasksParamsStatus = "queued"
	Running   ListTasksParamsStatus = "running"
	Succeeded ListTasksParamsStatus = "succeeded"
)

// AccessToken defines model for AccessToken.
type AccessToken struct {
	AccessToken string `json:"access_token"`
	ExpiresIn   int    `json:"expires_in"`
	TokenType   string `json:"token_type"`
}

// AccessTokenRequest defines model for AccessTokenRequest.
type AccessTokenRequest struct {
	ClientId     string  `json:"client_id"`
	ClientSecret string  `json:"client_secret"`
	GrantType    *string `json:"grant_type,omitempty"`
}

// ApiClient defines model for ApiClient.
type ApiClient struct {
	Auth0Id     string  `json:"auth0_id"`
	Auth0Secret *string `json:"auth0_secret,omitempty"`
	CreatedAt   string  `json:"created_at"`
	Description string  `json:"description"`
	Id          string  `json:"id"`
	Name        string  `json:"name"`
	UpdatedAt   string  `json:"updated_at"`
}

// AvailableCluster defines model for AvailableCluster.
type AvailableCluster struct {
	Id        string     `json:"id"`
	Locations []Location `json:"locations"`
	Name      string     `json:"name"`
}

// AwsCredentials defines model for AwsCredentials.
type AwsCredentials struct {
	RoleArn string `json:"role_arn"`
}

// AzureCredentials defines model for AzureCredentials.
type AzureCredentials struct {
	ClientId       string  `json:"client_id"`
	ClientSecret   string  `json:"client_secret"`
	ResourceGroup  *string `json:"resource_group,omitempty"`
	SubscriptionId string  `json:"subscription_id"`
	TenantId       string  `json:"tenant_id"`
}

// Backup defines model for Backup.
type Backup struct {
	Bucket     *string                `json:"bucket,omitempty"`
	CreatedAt  string                 `json:"created_at"`
	DatabaseId string                 `json:"database_id"`
	DateKey    *string                `json:"date_key,omitempty"`
	FinishedAt *string                `json:"finished_at,omitempty"`
	Id         string                 `json:"id"`
	Key        *string                `json:"key,omitempty"`
	Kind       string                 `json:"kind"`
	Metadata   map[string]interface{} `json:"metadata"`
	Name       string                 `json:"name"`
	Size       int64                  `json:"size"`
	Status     string                 `json:"status"`
	Url        *string                `json:"url,omitempty"`
}

// BackupConfig defines model for BackupConfig.
type BackupConfig struct {
	Id           string              `json:"id"`
	NodeName     *string             `json:"node_name,omitempty"`
	Repositories *[]BackupRepository `json:"repositories,omitempty"`
	Schedules    *[]BackupSchedule   `json:"schedules,omitempty"`
}

// BackupLink defines model for BackupLink.
type BackupLink struct {
	Url string `json:"url"`
}

// BackupRepository defines model for BackupRepository.
type BackupRepository struct {
	AzureAccount      *string `json:"azure_account,omitempty"`
	AzureContainer    *string `json:"azure_container,omitempty"`
	AzureEndpoint     *string `json:"azure_endpoint,omitempty"`
	BackupStoreId     *string `json:"backup_store_id,omitempty"`
	BasePath          *string `json:"base_path,omitempty"`
	CreatedAt         *string `json:"created_at,omitempty"`
	DatabaseId        *string `json:"database_id,omitempty"`
	GcsBucket         *string `json:"gcs_bucket,omitempty"`
	GcsEndpoint       *string `json:"gcs_endpoint,omitempty"`
	Id                *string `json:"id,omitempty"`
	RetentionFull     *int    `json:"retention_full,omitempty"`
	RetentionFullType *string `json:"retention_full_type,omitempty"`
	S3Bucket          *string `json:"s3_bucket,omitempty"`
	S3Endpoint        *string `json:"s3_endpoint,omitempty"`
	S3Region          *string `json:"s3_region,omitempty"`
	Type              *string `json:"type,omitempty"`
}

// BackupSchedule defines model for BackupSchedule.
type BackupSchedule struct {
	CronExpression string `json:"cron_expression"`
	Id             string `json:"id"`
	Type           string `json:"type"`
}

// BackupStore defines model for BackupStore.
type BackupStore struct {
	// CloudAccountId The ID of the cloud account used for the backup store.
	CloudAccountId string `json:"cloud_account_id"`

	// CloudAccountType The type of the cloud account used for the backup store.
	CloudAccountType string `json:"cloud_account_type"`

	// ClusterIds The IDs of the clusters that use the backup store.
	ClusterIds *[]string `json:"cluster_ids,omitempty"`

	// CreatedAt The time the backup store was created.
	CreatedAt string `json:"created_at"`

	// Id The ID of the backup store.
	Id string `json:"id"`

	// Name The name of the backup store.
	Name string `json:"name"`

	// Properties The computed properties of the backup store.
	Properties *map[string]interface{} `json:"properties,omitempty"`

	// Status The status of the backup store.
	Status string `json:"status"`

	// UpdatedAt The time the backup store was last updated.
	UpdatedAt string `json:"updated_at"`
}

// Backups defines model for Backups.
type Backups struct {
	Config   *[]BackupConfig `json:"config,omitempty"`
	Provider string          `json:"provider"`
}

// CloudAccount defines model for CloudAccount.
type CloudAccount struct {
	CreatedAt   string                 `json:"created_at"`
	Description *string                `json:"description,omitempty"`
	Id          string                 `json:"id"`
	Name        string                 `json:"name"`
	Properties  map[string]interface{} `json:"properties"`
	Type        string                 `json:"type"`
	UpdatedAt   string                 `json:"updated_at"`
}

// CloudAccountProperties defines model for CloudAccountProperties.
type CloudAccountProperties struct {
	Id   string  `json:"id"`
	Name *string `json:"name,omitempty"`
	Type *string `json:"type,omitempty"`
}

// CloudFormationTemplate defines model for CloudFormationTemplate.
type CloudFormationTemplate struct {
	Url string `json:"url"`
}

// Cluster defines model for Cluster.
type Cluster struct {
	BackupStoreIds *[]string                      `json:"backup_store_ids,omitempty"`
	Capacity       *int                           `json:"capacity,omitempty"`
	CloudAccount   CloudAccountProperties         `json:"cloud_account"`
	CreatedAt      string                         `json:"created_at"`
	FirewallRules  *[]ClusterFirewallRuleSettings `json:"firewall_rules,omitempty"`
	Id             string                         `json:"id"`
	Name           string                         `json:"name"`
	Networks       *[]ClusterNetworkSettings      `json:"networks,omitempty"`
	NodeLocation   string                         `json:"node_location"`
	Nodes          *[]ClusterNodeSettings         `json:"nodes,omitempty"`
	Regions        []string                       `json:"regions"`
	ResourceTags   *map[string]string             `json:"resource_tags,omitempty"`
	SshKeyId       *string                        `json:"ssh_key_id,omitempty"`
	Status         string                         `json:"status"`
}

// ClusterFirewallRuleSettings defines model for ClusterFirewallRuleSettings.
type ClusterFirewallRuleSettings struct {
	Name    *string  `json:"name,omitempty"`
	Port    int      `json:"port"`
	Sources []string `json:"sources"`
}

// ClusterNetworkSettings defines model for ClusterNetworkSettings.
type ClusterNetworkSettings struct {
	Cidr           *string   `json:"cidr,omitempty"`
	External       *bool     `json:"external,omitempty"`
	ExternalId     *string   `json:"external_id,omitempty"`
	Name           *string   `json:"name,omitempty"`
	PrivateSubnets *[]string `json:"private_subnets,omitempty"`
	PublicSubnets  *[]string `json:"public_subnets,omitempty"`
	Region         string    `json:"region"`
}

// ClusterNode defines model for ClusterNode.
type ClusterNode struct {
	AvailabilityZone    string               `json:"availability_zone"`
	DisplayName         *string              `json:"display_name,omitempty"`
	DistanceMeasurement *DistanceMeasurement `json:"distance_measurement,omitempty"`
	Id                  string               `json:"id"`
	ImageId             string               `json:"image_id"`
	InstanceId          string               `json:"instance_id"`
	InstanceType        string               `json:"instance_type"`
	IpAddress           string               `json:"ip_address"`
	IsActive            bool                 `json:"is_active"`
	KeyName             string               `json:"key_name"`
	Location            Location             `json:"location"`
	Name                string               `json:"name"`
	PublicIpAddress     *string              `json:"public_ip_address,omitempty"`
	Region              string               `json:"region"`
	RegionDetail        Region               `json:"region_detail"`
	VolumeIops          int                  `json:"volume_iops"`
	VolumeSize          int                  `json:"volume_size"`
	VolumeType          string               `json:"volume_type"`
}

// ClusterNodeLogMessage defines model for ClusterNodeLogMessage.
type ClusterNodeLogMessage struct {
	Level   string `json:"level"`
	Message string `json:"message"`
	RawText string `json:"raw_text"`
	Time    string `json:"time"`
}

// ClusterNodeSettings defines model for ClusterNodeSettings.
type ClusterNodeSettings struct {
	AvailabilityZone *string   `json:"availability_zone,omitempty"`
	InstanceType     *string   `json:"instance_type,omitempty"`
	Name             *string   `json:"name,omitempty"`
	Options          *[]string `json:"options,omitempty"`
	Region           string    `json:"region"`
	VolumeIops       *int      `json:"volume_iops,omitempty"`
	VolumeSize       *int      `json:"volume_size,omitempty"`
	VolumeType       *string   `json:"volume_type,omitempty"`
}

// ClusterShare defines model for ClusterShare.
type ClusterShare struct {
	AllowedTenants []string `json:"allowed_tenants"`
	Capacity       int      `json:"capacity"`
	CreatedAt      string   `json:"created_at"`
	Id             string   `json:"id"`
	Name           string   `json:"name"`
	Status         string   `json:"status"`
	Tenancy        string   `json:"tenancy"`
	UpdatedAt      string   `json:"updated_at"`
}

// ConfigVersion defines model for ConfigVersion.
type ConfigVersion struct {
	Images              *map[string]string `json:"images,omitempty"`
	ManagedExtensions   *[]string          `json:"managed_extensions,omitempty"`
	Name                string             `json:"name"`
	SupportedPgVersions *[]string          `json:"supported_pg_versions,omitempty"`
}

// Connection defines model for Connection.
type Connection struct {
	Database          string  `json:"database"`
	ExternalIpAddress *string `json:"external_ip_address,omitempty"`
	Host              *string `json:"host,omitempty"`
	InternalHost      *string `json:"internal_host,omitempty"`
	InternalIpAddress *string `json:"internal_ip_address,omitempty"`
	Password          string  `json:"password"`
	Port              int     `json:"port"`
	Username          string  `json:"username"`
}

// CreateApiClientInput defines model for CreateApiClientInput.
type CreateApiClientInput struct {
	Description string `json:"description"`
	Name        string `json:"name"`
}

// CreateBackupInput defines model for CreateBackupInput.
type CreateBackupInput struct {
	Name        *string   `json:"name,omitempty"`
	Provider    string    `json:"provider"`
	TargetNodes *[]string `json:"target_nodes,omitempty"`
	Type        *string   `json:"type,omitempty"`
}

// CreateBackupStoreInput defines model for CreateBackupStoreInput.
type CreateBackupStoreInput struct {
	// CloudAccountId The ID of the cloud account to use for the backup store.
	CloudAccountId string `json:"cloud_account_id"`

	// Name The name of the backup store.
	Name string `json:"name"`

	// Region The region to use for the backup store.
	Region *string `json:"region,omitempty"`
}

// CreateCloudAccountInput defines model for CreateCloudAccountInput.
type CreateCloudAccountInput struct {
	Credentials CreateCloudAccountInput_Credentials `json:"credentials"`
	Description *string                             `json:"description,omitempty"`
	Name        *string                             `json:"name,omitempty"`
	Type        string                              `json:"type"`
}

// CreateCloudAccountInput_Credentials defines model for CreateCloudAccountInput.Credentials.
type CreateCloudAccountInput_Credentials struct {
	union json.RawMessage
}

// CreateClusterInput defines model for CreateClusterInput.
type CreateClusterInput struct {
	BackupStoreIds *[]string                      `json:"backup_store_ids,omitempty"`
	Capacity       *int                           `json:"capacity,omitempty"`
	CloudAccount   *CloudAccountProperties        `json:"cloud_account,omitempty"`
	CloudAccountId *string                        `json:"cloud_account_id,omitempty"`
	FirewallRules  *[]ClusterFirewallRuleSettings `json:"firewall_rules,omitempty"`
	Name           string                         `json:"name"`
	Networks       *[]ClusterNetworkSettings      `json:"networks,omitempty"`
	NodeLocation   string                         `json:"node_location"`
	Nodes          *[]ClusterNodeSettings         `json:"nodes,omitempty"`
	Regions        []string                       `json:"regions"`
	ResourceTags   *map[string]string             `json:"resource_tags,omitempty"`
	SshKeyId       *string                        `json:"ssh_key_id,omitempty"`
}

// CreateClusterShareInput defines model for CreateClusterShareInput.
type CreateClusterShareInput struct {
	AllowedTenants *[]string                       `json:"allowed_tenants,omitempty"`
	Capacity       *int                            `json:"capacity,omitempty"`
	Name           *string                         `json:"name,omitempty"`
	Status         *string                         `json:"status,omitempty"`
	Tenancy        *CreateClusterShareInputTenancy `json:"tenancy,omitempty"`
}

// CreateClusterShareInputTenancy defines model for CreateClusterShareInput.Tenancy.
type CreateClusterShareInputTenancy string

// CreateDatabaseInput defines model for CreateDatabaseInput.
type CreateDatabaseInput struct {
	Backups       *Backups `json:"backups,omitempty"`
	ClusterId     *string  `json:"cluster_id,omitempty"`
	ConfigVersion *string  `json:"config_version,omitempty"`

	// DisplayName Display name for the database. Optional.
	// Must not exceed 25 characters.
	DisplayName *string     `json:"display_name"`
	Extensions  *Extensions `json:"extensions,omitempty"`
	Name        string      `json:"name"`
	Options     *[]string   `json:"options,omitempty"`
	PgVersion   *string     `json:"pg_version,omitempty"`
}

// CreateInviteInput defines model for CreateInviteInput.
type CreateInviteInput struct {
	Email      string `json:"email"`
	Expiration *int   `json:"expiration,omitempty"`
}

// CreateRestoreInput defines model for CreateRestoreInput.
type CreateRestoreInput struct {
	Provider       string                             `json:"provider"`
	RestoreCommand *CreateRestoreInput_RestoreCommand `json:"restore_command,omitempty"`
	RestoreConfig  CreateRestoreInput_RestoreConfig   `json:"restore_config"`
	TargetNodes    *[]string                          `json:"target_nodes,omitempty"`
}

// CreateRestoreInput_RestoreCommand defines model for CreateRestoreInput.RestoreCommand.
type CreateRestoreInput_RestoreCommand struct {
	union json.RawMessage
}

// CreateRestoreInput_RestoreConfig defines model for CreateRestoreInput.RestoreConfig.
type CreateRestoreInput_RestoreConfig struct {
	union json.RawMessage
}

// CreateSshKeyInput defines model for CreateSshKeyInput.
type CreateSshKeyInput struct {
	// Name The name of the SSH key.
	Name string `json:"name"`

	// PublicKey The public key of the SSH key pair.
	PublicKey string `json:"public_key"`
}

// Database defines model for Database.
type Database struct {
	Backups       *Backups                    `json:"backups,omitempty"`
	ClusterId     string                      `json:"cluster_id"`
	Components    *[]DatabaseComponentVersion `json:"components,omitempty"`
	ConfigVersion *string                     `json:"config_version,omitempty"`
	CreatedAt     string                      `json:"created_at"`

	// DisplayName Display name of the database. Will be null if not set.
	DisplayName   *string          `json:"display_name"`
	Domain        *string          `json:"domain,omitempty"`
	Extensions    *Extensions      `json:"extensions,omitempty"`
	Id            string           `json:"id"`
	Name          string           `json:"name"`
	Nodes         *[]DatabaseNode  `json:"nodes,omitempty"`
	Options       *[]string        `json:"options,omitempty"`
	PgVersion     *string          `json:"pg_version,omitempty"`
	PrivateDomain *string          `json:"private_domain,omitempty"`
	Roles         *[]DatabaseRole  `json:"roles,omitempty"`
	Status        string           `json:"status"`
	StorageUsed   *int64           `json:"storage_used,omitempty"`
	Tables        *[]DatabaseTable `json:"tables,omitempty"`
	UpdatedAt     string           `json:"updated_at"`
}

// DatabaseColumn defines model for DatabaseColumn.
type DatabaseColumn struct {
	DataType        string `json:"data_type"`
	Default         string `json:"default"`
	IsNullable      bool   `json:"is_nullable"`
	IsPrimaryKey    bool   `json:"is_primary_key"`
	Name            string `json:"name"`
	OrdinalPosition int    `json:"ordinal_position"`
}

// DatabaseComponentVersion defines model for DatabaseComponentVersion.
type DatabaseComponentVersion struct {
	Id          string `json:"id"`
	Name        string `json:"name"`
	ReleaseDate string `json:"release_date"`
	Status      string `json:"status"`
	Version     string `json:"version"`
}

// DatabaseLogsResponse defines model for DatabaseLogsResponse.
type DatabaseLogsResponse struct {
	Logs []map[string]interface{} `json:"logs"`
}

// DatabaseNode defines model for DatabaseNode.
type DatabaseNode struct {
	Connection          Connection              `json:"connection"`
	DistanceMeasurement *DistanceMeasurement    `json:"distance_measurement,omitempty"`
	Extensions          *DatabaseNodeExtensions `json:"extensions,omitempty"`
	Location            Location                `json:"location"`
	Name                string                  `json:"name"`
	Region              *Region                 `json:"region,omitempty"`
}

// DatabaseNodeExtensions defines model for DatabaseNodeExtensions.
type DatabaseNodeExtensions struct {
	Errors    *map[string]string `json:"errors,omitempty"`
	Installed []string           `json:"installed"`
}

// DatabaseRole defines model for DatabaseRole.
type DatabaseRole struct {
	BypassRls       bool   `json:"bypass_rls"`
	ConnectionLimit int    `json:"connection_limit"`
	CreateDb        bool   `json:"create_db"`
	CreateRole      bool   `json:"create_role"`
	Inherit         bool   `json:"inherit"`
	Login           bool   `json:"login"`
	Name            string `json:"name"`
	Replication     bool   `json:"replication"`
	Superuser       bool   `json:"superuser"`
}

// DatabaseTable defines model for DatabaseTable.
type DatabaseTable struct {
	Columns         *[]DatabaseColumn     `json:"columns,omitempty"`
	Name            string                `json:"name"`
	PrimaryKey      []string              `json:"primary_key"`
	ReplicationSets []string              `json:"replication_sets"`
	Schema          string                `json:"schema"`
	Status          []DatabaseTableStatus `json:"status"`
}

// DatabaseTableStatus defines model for DatabaseTableStatus.
type DatabaseTableStatus struct {
	Aligned     bool   `json:"aligned"`
	NodeName    string `json:"node_name"`
	Present     bool   `json:"present"`
	Replicating bool   `json:"replicating"`
}

// DistanceMeasurement defines model for DistanceMeasurement.
type DistanceMeasurement struct {
	Distance      float64 `json:"distance"`
	FromLatitude  float64 `json:"from_latitude"`
	FromLongitude float64 `json:"from_longitude"`
	Unit          string  `json:"unit"`
}

// Error defines model for Error.
type Error struct {
	Code    int    `json:"code"`
	Message string `json:"message"`
}

// Extensions defines model for Extensions.
type Extensions struct {
	AutoManage *bool     `json:"auto_manage,omitempty"`
	Available  *[]string `json:"available,omitempty"`
	Requested  *[]string `json:"requested,omitempty"`
}

// GoogleCredentials defines model for GoogleCredentials.
type GoogleCredentials struct {
	ProjectId      string `json:"project_id"`
	Provider       string `json:"provider"`
	ServiceAccount string `json:"service_account"`
}

// Invite defines model for Invite.
type Invite struct {
	AcceptUrl  *string `json:"accept_url,omitempty"`
	CreatedAt  string  `json:"created_at"`
	Email      string  `json:"email"`
	ExpiresAt  string  `json:"expires_at"`
	Id         string  `json:"id"`
	InvitedBy  *string `json:"invited_by,omitempty"`
	ScreenHint *string `json:"screen_hint,omitempty"`
	TeamName   string  `json:"team_name"`
	Token      *string `json:"token,omitempty"`
	UpdatedAt  string  `json:"updated_at"`
}

// Location defines model for Location.
type Location struct {
	City       *string `json:"city,omitempty"`
	Code       *string `json:"code,omitempty"`
	Country    *string `json:"country,omitempty"`
	Latitude   float64 `json:"latitude"`
	Longitude  float64 `json:"longitude"`
	MetroCode  *string `json:"metro_code,omitempty"`
	Name       *string `json:"name,omitempty"`
	PostalCode *string `json:"postal_code,omitempty"`
	Region     *string `json:"region,omitempty"`
	RegionCode *string `json:"region_code,omitempty"`
	Timezone   *string `json:"timezone,omitempty"`
}

// Membership defines model for Membership.
type Membership struct {
	CreatedAt   string  `json:"created_at"`
	Id          string  `json:"id"`
	UpdatedAt   string  `json:"updated_at"`
	UserEmail   string  `json:"user_email"`
	UserId      string  `json:"user_id"`
	UserName    string  `json:"user_name"`
	UserPicture *string `json:"user_picture,omitempty"`
}

// Message defines model for Message.
type Message struct {
	Level    string  `json:"level"`
	Progress *int    `json:"progress,omitempty"`
	Status   *string `json:"status,omitempty"`
	Step     *string `json:"step,omitempty"`
	Text     string  `json:"text"`
	Time     string  `json:"time"`
}

// Metric defines model for Metric.
type Metric struct {
	End   int64        `json:"end"`
	Items []MetricItem `json:"items"`
	Name  string       `json:"name"`
	Start int64        `json:"start"`
	Type  string       `json:"type"`
	Unit  string       `json:"unit"`
}

// MetricItem defines model for MetricItem.
type MetricItem struct {
	Name      string           `json:"name"`
	Resources []MetricResource `json:"resources"`
	Value     float64          `json:"value"`
	Values    [][]float64      `json:"values"`
}

// MetricResource defines model for MetricResource.
type MetricResource struct {
	Id   string `json:"id"`
	Name string `json:"name"`
	Type string `json:"type"`
}

// MetricSeries defines model for MetricSeries.
type MetricSeries struct {
	Columns []string        `json:"columns"`
	Name    string          `json:"name"`
	Values  [][]interface{} `json:"values"`
}

// MetricSeriesContainer defines model for MetricSeriesContainer.
type MetricSeriesContainer struct {
	Series []MetricSeries `json:"series"`
}

// Metrics defines model for Metrics.
type Metrics map[string]Metric

// OpenApiSpec defines model for OpenApiSpec.
type OpenApiSpec = map[string]interface{}

// PgBackrestBackupInfo defines model for PgBackrestBackupInfo.
type PgBackrestBackupInfo struct {
	Annotations        *map[string]string `json:"annotations,omitempty"`
	BackupSetSize      *int               `json:"backup_set_size,omitempty"`
	BackupSize         *int               `json:"backup_size,omitempty"`
	CreatedAt          *string            `json:"created_at,omitempty"`
	DatabaseBackupSize *int               `json:"database_backup_size,omitempty"`
	DatabaseSize       *int               `json:"database_size,omitempty"`
	Error              *bool              `json:"error,omitempty"`
	ErrorList          *[]string          `json:"error_list,omitempty"`
	FinishedAt         *string            `json:"finished_at,omitempty"`
	Label              *string            `json:"label,omitempty"`
	LsnStart           *string            `json:"lsn_start,omitempty"`
	LsnStop            *string            `json:"lsn_stop,omitempty"`
	PgbackrestFormat   *int               `json:"pgbackrest_format,omitempty"`
	PgbackrestVersion  *string            `json:"pgbackrest_version,omitempty"`
	Prior              *string            `json:"prior,omitempty"`
	References         *[]string          `json:"references,omitempty"`
	Type               *string            `json:"type,omitempty"`
	WalStart           *string            `json:"wal_start,omitempty"`
	WalStop            *string            `json:"wal_stop,omitempty"`
}

// PgBackrestRepositoryInfo defines model for PgBackrestRepositoryInfo.
type PgBackrestRepositoryInfo struct {
	ArchiveMaxWal      *string                 `json:"archive_max_wal,omitempty"`
	ArchiveMinWal      *string                 `json:"archive_min_wal,omitempty"`
	BackupRepositoryId string                  `json:"backup_repository_id"`
	Backups            *[]PgBackrestBackupInfo `json:"backups,omitempty"`
	DatabaseId         string                  `json:"database_id"`
	NodeName           string                  `json:"node_name"`
	PgSystemId         *int                    `json:"pg_system_id,omitempty"`
	PgVersion          *string                 `json:"pg_version,omitempty"`
	Status             *string                 `json:"status,omitempty"`
	StatusCode         *int                    `json:"status_code,omitempty"`
	StatusMessage      *string                 `json:"status_message,omitempty"`
}

// PgBackrestRestoreCommand defines model for PgBackrestRestoreCommand.
type PgBackrestRestoreCommand struct {
	Delta           *bool   `json:"delta,omitempty"`
	Force           *bool   `json:"force,omitempty"`
	Set             *string `json:"set,omitempty"`
	Target          *string `json:"target,omitempty"`
	TargetExclusive *bool   `json:"target_exclusive,omitempty"`
	Type            *string `json:"type,omitempty"`
}

// PgBackrestRestoreConfig defines model for PgBackrestRestoreConfig.
type PgBackrestRestoreConfig struct {
	NodeName     string   `json:"node_name"`
	Repositories []string `json:"repositories"`
}

// PgDumpRestoreCommand defines model for PgDumpRestoreCommand.
type PgDumpRestoreCommand struct {
	SchemaOnly *bool `json:"schema_only,omitempty"`
}

// PgDumpRestoreConfig defines model for PgDumpRestoreConfig.
type PgDumpRestoreConfig struct {
	BackupId string `json:"backup_id"`
}

// Region defines model for Region.
type Region struct {
	Active            *bool    `json:"active,omitempty"`
	AvailabilityZones []string `json:"availability_zones"`
	Cloud             string   `json:"cloud"`
	Code              string   `json:"code"`
	Name              string   `json:"name"`
	Parent            *string  `json:"parent,omitempty"`
}

// SshKey defines model for SshKey.
type SshKey struct {
	// CreatedAt The date and time when the SSH key was created.
	CreatedAt string `json:"created_at"`

	// Id The unique identifier of the SSH key.
	Id string `json:"id"`

	// Name The name of the SSH key.
	Name string `json:"name"`

	// PublicKey The public key of the SSH key.
	PublicKey string `json:"public_key"`
}

// TableQueryResponse defines model for TableQueryResponse.
type TableQueryResponse struct {
	Count int                      `json:"count"`
	Rows  []map[string]interface{} `json:"rows"`
}

// Task defines model for Task.
type Task struct {
	CreatedAt   string                  `json:"created_at"`
	Error       *string                 `json:"error,omitempty"`
	Id          string                  `json:"id"`
	Messages    []Message               `json:"messages"`
	Name        string                  `json:"name"`
	Request     *map[string]interface{} `json:"request,omitempty"`
	Response    *map[string]interface{} `json:"response,omitempty"`
	Status      string                  `json:"status"`
	SubjectId   string                  `json:"subject_id"`
	SubjectKind string                  `json:"subject_kind"`
	UpdatedAt   string                  `json:"updated_at"`
}

// Tenant defines model for Tenant.
type Tenant struct {
	CreatedAt     string  `json:"created_at"`
	Domain        *string `json:"domain,omitempty"`
	ExternalId    *string `json:"external_id,omitempty"`
	Id            string  `json:"id"`
	Name          string  `json:"name"`
	Plan          *string `json:"plan,omitempty"`
	PlanExpiresAt *string `json:"plan_expires_at,omitempty"`
	PlanTrial     *bool   `json:"plan_trial,omitempty"`
	UpdatedAt     string  `json:"updated_at"`
}

// UpdateApiClientInput defines model for UpdateApiClientInput.
type UpdateApiClientInput struct {
	Description *string `json:"description,omitempty"`
	Name        *string `json:"name,omitempty"`
}

// UpdateClusterInput defines model for UpdateClusterInput.
type UpdateClusterInput struct {
	BackupStoreIds *[]string                      `json:"backup_store_ids,omitempty"`
	FirewallRules  *[]ClusterFirewallRuleSettings `json:"firewall_rules,omitempty"`
	Networks       *[]ClusterNetworkSettings      `json:"networks,omitempty"`
	Nodes          *[]ClusterNodeSettings         `json:"nodes,omitempty"`
	Regions        []string                       `json:"regions"`
	ResourceTags   *map[string]string             `json:"resource_tags,omitempty"`
}

// UpdateDatabaseInput defines model for UpdateDatabaseInput.
type UpdateDatabaseInput struct {
	// DisplayName Display name for the database. Optional.
	// Set to empty string to remove existing display name.
	// Must not exceed 25 characters.
	DisplayName *string         `json:"display_name"`
	Extensions  *Extensions     `json:"extensions,omitempty"`
	Nodes       *[]DatabaseNode `json:"nodes,omitempty"`
	Options     *[]string       `json:"options,omitempty"`
}

// UpdateTenantInput defines model for UpdateTenantInput.
type UpdateTenantInput struct {
	Name *string `json:"name,omitempty"`
}

// UpdateUserInput defines model for UpdateUserInput.
type UpdateUserInput struct {
	FirstName *string `json:"first_name,omitempty"`
	LastName  *string `json:"last_name,omitempty"`
}

// User defines model for User.
type User struct {
	CreatedAt string   `json:"created_at"`
	Email     string   `json:"email"`
	FirstName *string  `json:"first_name,omitempty"`
	Id        string   `json:"id"`
	LastName  *string  `json:"last_name,omitempty"`
	Picture   *string  `json:"picture,omitempty"`
	Tenants   []Tenant `json:"tenants"`
	UpdatedAt string   `json:"updated_at"`
}

// ListBackupRepositoriesParams defines parameters for ListBackupRepositories.
type ListBackupRepositoriesParams struct {
	// DatabaseId Filter backup repositories to a specific database ID.
	DatabaseId *openapi_types.UUID `form:"database_id,omitempty" json:"database_id,omitempty"`

	// Type Filter backup repositories to a specific type.
	Type *string `form:"type,omitempty" json:"type,omitempty"`

	// CreatedAfter Start time for backup repository retrieval as an RFC3339 timestamp.
	CreatedAfter *time.Time `form:"created_after,omitempty" json:"created_after,omitempty"`

	// CreatedBefore End time for backup repository retrieval as an RFC3339 timestamp.
	CreatedBefore *time.Time `form:"created_before,omitempty" json:"created_before,omitempty"`

	// Limit Maximum number of results to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Offset into the results for pagination.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Descending Sort in descending order.
	Descending *bool `form:"descending,omitempty" json:"descending,omitempty"`
}

// GetBackupRepositoryInfoParams defines parameters for GetBackupRepositoryInfo.
type GetBackupRepositoryInfoParams struct {
	// BackupLimit Maximum number of backups to return.
	BackupLimit *int `form:"backup_limit,omitempty" json:"backup_limit,omitempty"`

	// BackupOffset Offset into the backups, for pagination.
	BackupOffset *int `form:"backup_offset,omitempty" json:"backup_offset,omitempty"`

	// BackupType Filter backups by type.
	BackupType *GetBackupRepositoryInfoParamsBackupType `form:"backup_type,omitempty" json:"backup_type,omitempty"`

	// Descending Sort backups in descending order.
	Descending *bool `form:"descending,omitempty" json:"descending,omitempty"`
}

// GetBackupRepositoryInfoParamsBackupType defines parameters for GetBackupRepositoryInfo.
type GetBackupRepositoryInfoParamsBackupType string

// ListBackupStoresParams defines parameters for ListBackupStores.
type ListBackupStoresParams struct {
	// CreatedAfter Start time for backup store retrieval as an RFC3339 timestamp.
	CreatedAfter *time.Time `form:"created_after,omitempty" json:"created_after,omitempty"`

	// CreatedBefore End time for backup store retrieval as an RFC3339 timestamp.
	CreatedBefore *time.Time `form:"created_before,omitempty" json:"created_before,omitempty"`

	// Limit Maximum number of results to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Offset into the results for pagination.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Descending Sort in descending order.
	Descending *bool `form:"descending,omitempty" json:"descending,omitempty"`
}

// ListBackupsParams defines parameters for ListBackups.
type ListBackupsParams struct {
	// DatabaseId Filter backups to a specific database ID.
	DatabaseId *openapi_types.UUID `form:"database_id,omitempty" json:"database_id,omitempty"`

	// Kind Filter backups to a specific kind.
	Kind *string `form:"kind,omitempty" json:"kind,omitempty"`

	// CreatedAfter Start time for backup retrieval as an RFC3339 timestamp.
	CreatedAfter *time.Time `form:"created_after,omitempty" json:"created_after,omitempty"`

	// CreatedBefore End time for backup retrieval as an RFC3339 timestamp.
	CreatedBefore *time.Time `form:"created_before,omitempty" json:"created_before,omitempty"`

	// Limit Maximum number of results to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Offset into the results for pagination.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Descending Sort in descending order.
	Descending *bool `form:"descending,omitempty" json:"descending,omitempty"`
}

// ListClustersParams defines parameters for ListClusters.
type ListClustersParams struct {
	// CreatedAfter Start time for cluster retrieval as an RFC3339 timestamp.
	CreatedAfter *time.Time `form:"created_after,omitempty" json:"created_after,omitempty"`

	// CreatedBefore End time for cluster retrieval as an RFC3339 timestamp.
	CreatedBefore *time.Time `form:"created_before,omitempty" json:"created_before,omitempty"`

	// Limit Maximum number of results to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Offset into the results for pagination.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Descending Sort in descending order.
	Descending *bool `form:"descending,omitempty" json:"descending,omitempty"`
}

// ReadClusterMetricsParams defines parameters for ReadClusterMetrics.
type ReadClusterMetricsParams struct {
	// StartTime Start time for metrics retrieval.
	StartTime *string `form:"start_time,omitempty" json:"start_time,omitempty"`

	// EndTime End time for metrics retrieval.
	EndTime *string `form:"end_time,omitempty" json:"end_time,omitempty"`
}

// ListClusterNodesParams defines parameters for ListClusterNodes.
type ListClusterNodesParams struct {
	// NearLat Latitude of the caller.
	NearLat *string `form:"near_lat,omitempty" json:"near_lat,omitempty"`

	// NearLon Longitude of the caller.
	NearLon *string `form:"near_lon,omitempty" json:"near_lon,omitempty"`

	// OrderBy Order by specification.
	OrderBy *ListClusterNodesParamsOrderBy `form:"order_by,omitempty" json:"order_by,omitempty"`
}

// ListClusterNodesParamsOrderBy defines parameters for ListClusterNodes.
type ListClusterNodesParamsOrderBy string

// GetClusterLogsParams defines parameters for GetClusterLogs.
type GetClusterLogsParams struct {
	// Lines Maximum number of log lines to retrieve.
	Lines *int `form:"lines,omitempty" json:"lines,omitempty"`

	// Since Show entries on or after the specified date.
	Since *string `form:"since,omitempty" json:"since,omitempty"`

	// Until Show entries on or before than the specified date.
	Until *string `form:"until,omitempty" json:"until,omitempty"`

	// Priority The message priority to filter the log files by.
	Priority *string `form:"priority,omitempty" json:"priority,omitempty"`

	// Grep Filter output to entries where the message field matches the provided regular expression.
	Grep *string `form:"grep,omitempty" json:"grep,omitempty"`

	// CaseSensitive If set to true, make pattern matching case-sensitive; the default is false (case-insensitive).
	CaseSensitive *bool `form:"case_sensitive,omitempty" json:"case_sensitive,omitempty"`

	// Reverse Reverse output so that the newest entries are displayed first.
	Reverse *bool `form:"reverse,omitempty" json:"reverse,omitempty"`

	// Dmesg Show only kernel entries.
	Dmesg *bool `form:"dmesg,omitempty" json:"dmesg,omitempty"`

	// Output Controls the formatting of the journal entries that are shown.
	Output *string `form:"output,omitempty" json:"output,omitempty"`
}

// ListDatabasesParams defines parameters for ListDatabases.
type ListDatabasesParams struct {
	// ClusterId Filter databases to a specific cluster ID.
	ClusterId *openapi_types.UUID `form:"cluster_id,omitempty" json:"cluster_id,omitempty"`

	// CreatedAfter Start time for database retrieval as an RFC3339 timestamp.
	CreatedAfter *time.Time `form:"created_after,omitempty" json:"created_after,omitempty"`

	// CreatedBefore End time for database retrieval as an RFC3339 timestamp.
	CreatedBefore *time.Time `form:"created_before,omitempty" json:"created_before,omitempty"`

	// Limit Maximum number of results to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Offset into the results for pagination.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Descending Sort in descending order.
	Descending *bool `form:"descending,omitempty" json:"descending,omitempty"`
}

// GetDatabaseParams defines parameters for GetDatabase.
type GetDatabaseParams struct {
	// UserType The user type whose credentials will be returned.
	UserType *string `form:"user_type,omitempty" json:"user_type,omitempty"`
}

// GetDatabaseLogsParams defines parameters for GetDatabaseLogs.
type GetDatabaseLogsParams struct {
	// ComponentName Name of the database to get logs for.
	ComponentName string `form:"component_name" json:"component_name"`

	// MaxLines Maximum number of log lines to retrieve.
	MaxLines *int `form:"max_lines,omitempty" json:"max_lines,omitempty"`

	// Nodes List of node(s) to get logs for.
	Nodes string `form:"nodes" json:"nodes"`
}

// GetDatabaseMetricsParams defines parameters for GetDatabaseMetrics.
type GetDatabaseMetricsParams struct {
	// Interval The interval to group the metrics by, specified in value, unit format.
	Interval *string `form:"interval,omitempty" json:"interval,omitempty"`

	// NodeName The node name to filter the metrics by.
	NodeName *string `form:"node_name,omitempty" json:"node_name,omitempty"`

	// Columns The columns to return, comma separated.
	Columns *string `form:"columns,omitempty" json:"columns,omitempty"`
}

// RotateDatabaseRolePasswordParamsRoleName defines parameters for RotateDatabaseRolePassword.
type RotateDatabaseRolePasswordParamsRoleName string

// QueryDatabaseTableParams defines parameters for QueryDatabaseTable.
type QueryDatabaseTableParams struct {
	// Table The table name.
	Table string `form:"table" json:"table"`

	// Schema The schema name.
	Schema *string `form:"schema,omitempty" json:"schema,omitempty"`

	// Limit The maximum number of rows to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of rows to skip.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// OrderBy The column to order by.
	OrderBy *string `form:"order_by,omitempty" json:"order_by,omitempty"`

	// Descending Sort results in descending order.
	Descending *bool `form:"descending,omitempty" json:"descending,omitempty"`

	// Filter The WHERE clause and values to inject in JSON string format.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`
}

// AcceptInviteParams defines parameters for AcceptInvite.
type AcceptInviteParams struct {
	// InviteToken Invite token.
	InviteToken string `form:"invite_token" json:"invite_token"`
}

// ListTasksParams defines parameters for ListTasks.
type ListTasksParams struct {
	// SubjectId Filter tasks by subject id.
	SubjectId *string `form:"subject_id,omitempty" json:"subject_id,omitempty"`

	// SubjectKind Filter tasks by kind.
	SubjectKind *string `form:"subject_kind,omitempty" json:"subject_kind,omitempty"`

	// Id Filter tasks by id.
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Name Filter tasks by name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Status Filter tasks by status.
	Status *ListTasksParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// Limit Maximum number of results to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Offset into the results for pagination.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListTasksParamsStatus defines parameters for ListTasks.
type ListTasksParamsStatus string

// CreateBackupStoreJSONRequestBody defines body for CreateBackupStore for application/json ContentType.
type CreateBackupStoreJSONRequestBody = CreateBackupStoreInput

// CreateClientJSONRequestBody defines body for CreateClient for application/json ContentType.
type CreateClientJSONRequestBody = CreateApiClientInput

// UpdateClientJSONRequestBody defines body for UpdateClient for application/json ContentType.
type UpdateClientJSONRequestBody = UpdateApiClientInput

// CreateCloudAccountJSONRequestBody defines body for CreateCloudAccount for application/json ContentType.
type CreateCloudAccountJSONRequestBody = CreateCloudAccountInput

// CreateClusterJSONRequestBody defines body for CreateCluster for application/json ContentType.
type CreateClusterJSONRequestBody = CreateClusterInput

// UpdateClusterJSONRequestBody defines body for UpdateCluster for application/json ContentType.
type UpdateClusterJSONRequestBody = UpdateClusterInput

// CreateClusterShareJSONRequestBody defines body for CreateClusterShare for application/json ContentType.
type CreateClusterShareJSONRequestBody = CreateClusterShareInput

// CreateDatabaseJSONRequestBody defines body for CreateDatabase for application/json ContentType.
type CreateDatabaseJSONRequestBody = CreateDatabaseInput

// UpdateDatabaseJSONRequestBody defines body for UpdateDatabase for application/json ContentType.
type UpdateDatabaseJSONRequestBody = UpdateDatabaseInput

// BackupDatabaseJSONRequestBody defines body for BackupDatabase for application/json ContentType.
type BackupDatabaseJSONRequestBody = CreateBackupInput

// RestoreDatabaseJSONRequestBody defines body for RestoreDatabase for application/json ContentType.
type RestoreDatabaseJSONRequestBody = CreateRestoreInput

// CreateInviteJSONRequestBody defines body for CreateInvite for application/json ContentType.
type CreateInviteJSONRequestBody = CreateInviteInput

// GenerateAccessTokenJSONRequestBody defines body for GenerateAccessToken for application/json ContentType.
type GenerateAccessTokenJSONRequestBody = AccessTokenRequest

// GenerateAccessTokenFormdataRequestBody defines body for GenerateAccessToken for application/x-www-form-urlencoded ContentType.
type GenerateAccessTokenFormdataRequestBody = AccessTokenRequest

// CreateSshKeyJSONRequestBody defines body for CreateSshKey for application/json ContentType.
type CreateSshKeyJSONRequestBody = CreateSshKeyInput

// UpdateTenantJSONRequestBody defines body for UpdateTenant for application/json ContentType.
type UpdateTenantJSONRequestBody = UpdateTenantInput

// UpdateCurrentUserJSONRequestBody defines body for UpdateCurrentUser for application/json ContentType.
type UpdateCurrentUserJSONRequestBody = UpdateUserInput

// AsAwsCredentials returns the union data inside the CreateCloudAccountInput_Credentials as a AwsCredentials
func (t CreateCloudAccountInput_Credentials) AsAwsCredentials() (AwsCredentials, error) {
	var body AwsCredentials
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAwsCredentials overwrites any union data inside the CreateCloudAccountInput_Credentials as the provided AwsCredentials
func (t *CreateCloudAccountInput_Credentials) FromAwsCredentials(v AwsCredentials) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAwsCredentials performs a merge with any union data inside the CreateCloudAccountInput_Credentials, using the provided AwsCredentials
func (t *CreateCloudAccountInput_Credentials) MergeAwsCredentials(v AwsCredentials) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAzureCredentials returns the union data inside the CreateCloudAccountInput_Credentials as a AzureCredentials
func (t CreateCloudAccountInput_Credentials) AsAzureCredentials() (AzureCredentials, error) {
	var body AzureCredentials
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAzureCredentials overwrites any union data inside the CreateCloudAccountInput_Credentials as the provided AzureCredentials
func (t *CreateCloudAccountInput_Credentials) FromAzureCredentials(v AzureCredentials) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAzureCredentials performs a merge with any union data inside the CreateCloudAccountInput_Credentials, using the provided AzureCredentials
func (t *CreateCloudAccountInput_Credentials) MergeAzureCredentials(v AzureCredentials) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGoogleCredentials returns the union data inside the CreateCloudAccountInput_Credentials as a GoogleCredentials
func (t CreateCloudAccountInput_Credentials) AsGoogleCredentials() (GoogleCredentials, error) {
	var body GoogleCredentials
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGoogleCredentials overwrites any union data inside the CreateCloudAccountInput_Credentials as the provided GoogleCredentials
func (t *CreateCloudAccountInput_Credentials) FromGoogleCredentials(v GoogleCredentials) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGoogleCredentials performs a merge with any union data inside the CreateCloudAccountInput_Credentials, using the provided GoogleCredentials
func (t *CreateCloudAccountInput_Credentials) MergeGoogleCredentials(v GoogleCredentials) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateCloudAccountInput_Credentials) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateCloudAccountInput_Credentials) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPgBackrestRestoreCommand returns the union data inside the CreateRestoreInput_RestoreCommand as a PgBackrestRestoreCommand
func (t CreateRestoreInput_RestoreCommand) AsPgBackrestRestoreCommand() (PgBackrestRestoreCommand, error) {
	var body PgBackrestRestoreCommand
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPgBackrestRestoreCommand overwrites any union data inside the CreateRestoreInput_RestoreCommand as the provided PgBackrestRestoreCommand
func (t *CreateRestoreInput_RestoreCommand) FromPgBackrestRestoreCommand(v PgBackrestRestoreCommand) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePgBackrestRestoreCommand performs a merge with any union data inside the CreateRestoreInput_RestoreCommand, using the provided PgBackrestRestoreCommand
func (t *CreateRestoreInput_RestoreCommand) MergePgBackrestRestoreCommand(v PgBackrestRestoreCommand) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPgDumpRestoreCommand returns the union data inside the CreateRestoreInput_RestoreCommand as a PgDumpRestoreCommand
func (t CreateRestoreInput_RestoreCommand) AsPgDumpRestoreCommand() (PgDumpRestoreCommand, error) {
	var body PgDumpRestoreCommand
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPgDumpRestoreCommand overwrites any union data inside the CreateRestoreInput_RestoreCommand as the provided PgDumpRestoreCommand
func (t *CreateRestoreInput_RestoreCommand) FromPgDumpRestoreCommand(v PgDumpRestoreCommand) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePgDumpRestoreCommand performs a merge with any union data inside the CreateRestoreInput_RestoreCommand, using the provided PgDumpRestoreCommand
func (t *CreateRestoreInput_RestoreCommand) MergePgDumpRestoreCommand(v PgDumpRestoreCommand) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateRestoreInput_RestoreCommand) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateRestoreInput_RestoreCommand) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPgBackrestRestoreConfig returns the union data inside the CreateRestoreInput_RestoreConfig as a PgBackrestRestoreConfig
func (t CreateRestoreInput_RestoreConfig) AsPgBackrestRestoreConfig() (PgBackrestRestoreConfig, error) {
	var body PgBackrestRestoreConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPgBackrestRestoreConfig overwrites any union data inside the CreateRestoreInput_RestoreConfig as the provided PgBackrestRestoreConfig
func (t *CreateRestoreInput_RestoreConfig) FromPgBackrestRestoreConfig(v PgBackrestRestoreConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePgBackrestRestoreConfig performs a merge with any union data inside the CreateRestoreInput_RestoreConfig, using the provided PgBackrestRestoreConfig
func (t *CreateRestoreInput_RestoreConfig) MergePgBackrestRestoreConfig(v PgBackrestRestoreConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPgDumpRestoreConfig returns the union data inside the CreateRestoreInput_RestoreConfig as a PgDumpRestoreConfig
func (t CreateRestoreInput_RestoreConfig) AsPgDumpRestoreConfig() (PgDumpRestoreConfig, error) {
	var body PgDumpRestoreConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPgDumpRestoreConfig overwrites any union data inside the CreateRestoreInput_RestoreConfig as the provided PgDumpRestoreConfig
func (t *CreateRestoreInput_RestoreConfig) FromPgDumpRestoreConfig(v PgDumpRestoreConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePgDumpRestoreConfig performs a merge with any union data inside the CreateRestoreInput_RestoreConfig, using the provided PgDumpRestoreConfig
func (t *CreateRestoreInput_RestoreConfig) MergePgDumpRestoreConfig(v PgDumpRestoreConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateRestoreInput_RestoreConfig) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateRestoreInput_RestoreConfig) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListAvailableClusters request
	ListAvailableClusters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBackupRepositories request
	ListBackupRepositories(ctx context.Context, params *ListBackupRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBackupRepositoryInfo request
	GetBackupRepositoryInfo(ctx context.Context, id string, nodeName string, params *GetBackupRepositoryInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBackupStores request
	ListBackupStores(ctx context.Context, params *ListBackupStoresParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBackupStoreWithBody request with any body
	CreateBackupStoreWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBackupStore(ctx context.Context, body CreateBackupStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBackupStore request
	DeleteBackupStore(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBackupStore request
	GetBackupStore(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBackups request
	ListBackups(ctx context.Context, params *ListBackupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBackup request
	DeleteBackup(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBackup request
	GetBackup(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBackupLink request
	GetBackupLink(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListClients request
	ListClients(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClientWithBody request with any body
	CreateClientWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateClient(ctx context.Context, body CreateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteClient request
	DeleteClient(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClient request
	GetClient(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateClientWithBody request with any body
	UpdateClientWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateClient(ctx context.Context, id string, body UpdateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCloudAccounts request
	ListCloudAccounts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCloudAccountWithBody request with any body
	CreateCloudAccountWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCloudAccount(ctx context.Context, body CreateCloudAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCloudAccount request
	DeleteCloudAccount(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCloudAccount request
	GetCloudAccount(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListClusters request
	ListClusters(ctx context.Context, params *ListClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClusterWithBody request with any body
	CreateClusterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCluster(ctx context.Context, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCluster request
	DeleteCluster(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCluster request
	GetCluster(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateClusterWithBody request with any body
	UpdateClusterWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCluster(ctx context.Context, id string, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadClusterMetrics request
	ReadClusterMetrics(ctx context.Context, id string, params *ReadClusterMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListClusterNodes request
	ListClusterNodes(ctx context.Context, id string, params *ListClusterNodesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClusterLogs request
	GetClusterLogs(ctx context.Context, id string, nodeId string, logName string, params *GetClusterLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListClusterShares request
	ListClusterShares(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClusterShareWithBody request with any body
	CreateClusterShareWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateClusterShare(ctx context.Context, id string, body CreateClusterShareJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteClusterShare request
	DeleteClusterShare(ctx context.Context, id string, shareId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadClusterShare request
	ReadClusterShare(ctx context.Context, id string, shareId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListConfigVersions request
	ListConfigVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfigVersion request
	GetConfigVersion(ctx context.Context, version string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDatabases request
	ListDatabases(ctx context.Context, params *ListDatabasesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDatabaseWithBody request with any body
	CreateDatabaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDatabase(ctx context.Context, body CreateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDatabase request
	DeleteDatabase(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDatabase request
	GetDatabase(ctx context.Context, id string, params *GetDatabaseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDatabaseWithBody request with any body
	UpdateDatabaseWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDatabase(ctx context.Context, id string, body UpdateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BackupDatabaseWithBody request with any body
	BackupDatabaseWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BackupDatabase(ctx context.Context, id string, body BackupDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDatabaseLogs request
	GetDatabaseLogs(ctx context.Context, id string, params *GetDatabaseLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDatabaseMetrics request
	GetDatabaseMetrics(ctx context.Context, id string, params *GetDatabaseMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplicateDatabase request
	ReplicateDatabase(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestoreDatabaseWithBody request with any body
	RestoreDatabaseWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RestoreDatabase(ctx context.Context, id string, body RestoreDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RotateDatabaseRolePassword request
	RotateDatabaseRolePassword(ctx context.Context, id string, roleName RotateDatabaseRolePasswordParamsRoleName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueryDatabaseTable request
	QueryDatabaseTable(ctx context.Context, id string, params *QueryDatabaseTableParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListInvites request
	ListInvites(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateInviteWithBody request with any body
	CreateInviteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateInvite(ctx context.Context, body CreateInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInvite request
	DeleteInvite(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvite request
	GetInvite(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AcceptInvite request
	AcceptInvite(ctx context.Context, id string, params *AcceptInviteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMemberships request
	ListMemberships(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMembership request
	DeleteMembership(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateAccessTokenWithBody request with any body
	GenerateAccessTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenerateAccessToken(ctx context.Context, body GenerateAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenerateAccessTokenWithFormdataBody(ctx context.Context, body GenerateAccessTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOpenApiSpec request
	GetOpenApiSpec(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSshKeys request
	ListSshKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSshKeyWithBody request with any body
	CreateSshKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSshKey(ctx context.Context, body CreateSshKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSshKey request
	DeleteSshKey(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSshKey request
	GetSshKey(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTasks request
	ListTasks(ctx context.Context, params *ListTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCloudFormationTemplate request
	GetCloudFormationTemplate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTenants request
	ListTenants(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTenant request
	GetTenant(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTenantWithBody request with any body
	UpdateTenantWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTenant(ctx context.Context, id string, body UpdateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentUser request
	GetCurrentUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCurrentUserWithBody request with any body
	UpdateCurrentUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCurrentUser(ctx context.Context, body UpdateCurrentUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListAvailableClusters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAvailableClustersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBackupRepositories(ctx context.Context, params *ListBackupRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBackupRepositoriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBackupRepositoryInfo(ctx context.Context, id string, nodeName string, params *GetBackupRepositoryInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBackupRepositoryInfoRequest(c.Server, id, nodeName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBackupStores(ctx context.Context, params *ListBackupStoresParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBackupStoresRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBackupStoreWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBackupStoreRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBackupStore(ctx context.Context, body CreateBackupStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBackupStoreRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBackupStore(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBackupStoreRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBackupStore(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBackupStoreRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBackups(ctx context.Context, params *ListBackupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBackupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBackup(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBackupRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBackup(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBackupRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBackupLink(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBackupLinkRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListClients(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClientsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClient(ctx context.Context, body CreateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteClient(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClientRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClient(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClientWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClientRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClient(ctx context.Context, id string, body UpdateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClientRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCloudAccounts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCloudAccountsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCloudAccountWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCloudAccountRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCloudAccount(ctx context.Context, body CreateCloudAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCloudAccountRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCloudAccount(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCloudAccountRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCloudAccount(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCloudAccountRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListClusters(ctx context.Context, params *ListClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClustersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClusterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCluster(ctx context.Context, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCluster(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClusterRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCluster(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClusterWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClusterRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCluster(ctx context.Context, id string, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClusterRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadClusterMetrics(ctx context.Context, id string, params *ReadClusterMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadClusterMetricsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListClusterNodes(ctx context.Context, id string, params *ListClusterNodesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClusterNodesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClusterLogs(ctx context.Context, id string, nodeId string, logName string, params *GetClusterLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterLogsRequest(c.Server, id, nodeId, logName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListClusterShares(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClusterSharesRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClusterShareWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterShareRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClusterShare(ctx context.Context, id string, body CreateClusterShareJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterShareRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteClusterShare(ctx context.Context, id string, shareId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClusterShareRequest(c.Server, id, shareId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadClusterShare(ctx context.Context, id string, shareId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadClusterShareRequest(c.Server, id, shareId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListConfigVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListConfigVersionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfigVersion(ctx context.Context, version string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigVersionRequest(c.Server, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDatabases(ctx context.Context, params *ListDatabasesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDatabasesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatabaseRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabase(ctx context.Context, body CreateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatabaseRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDatabase(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDatabaseRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatabase(ctx context.Context, id string, params *GetDatabaseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDatabaseRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDatabaseWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDatabaseRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDatabase(ctx context.Context, id string, body UpdateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDatabaseRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BackupDatabaseWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBackupDatabaseRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BackupDatabase(ctx context.Context, id string, body BackupDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBackupDatabaseRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatabaseLogs(ctx context.Context, id string, params *GetDatabaseLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDatabaseLogsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatabaseMetrics(ctx context.Context, id string, params *GetDatabaseMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDatabaseMetricsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplicateDatabase(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplicateDatabaseRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreDatabaseWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreDatabaseRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreDatabase(ctx context.Context, id string, body RestoreDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreDatabaseRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RotateDatabaseRolePassword(ctx context.Context, id string, roleName RotateDatabaseRolePasswordParamsRoleName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRotateDatabaseRolePasswordRequest(c.Server, id, roleName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryDatabaseTable(ctx context.Context, id string, params *QueryDatabaseTableParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryDatabaseTableRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInvites(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInvitesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateInviteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateInviteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateInvite(ctx context.Context, body CreateInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateInviteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInvite(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInviteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvite(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInviteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcceptInvite(ctx context.Context, id string, params *AcceptInviteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptInviteRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMemberships(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMembershipsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMembership(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMembershipRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateAccessTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateAccessTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateAccessToken(ctx context.Context, body GenerateAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateAccessTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateAccessTokenWithFormdataBody(ctx context.Context, body GenerateAccessTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateAccessTokenRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOpenApiSpec(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOpenApiSpecRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSshKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSshKeysRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSshKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSshKeyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSshKey(ctx context.Context, body CreateSshKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSshKeyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSshKey(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSshKeyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSshKey(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSshKeyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTasks(ctx context.Context, params *ListTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTasksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCloudFormationTemplate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCloudFormationTemplateRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTenants(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTenantsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTenant(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTenantRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTenantWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTenantRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTenant(ctx context.Context, id string, body UpdateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTenantRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCurrentUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCurrentUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCurrentUser(ctx context.Context, body UpdateCurrentUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCurrentUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListAvailableClustersRequest generates requests for ListAvailableClusters
func NewListAvailableClustersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/available-clusters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBackupRepositoriesRequest generates requests for ListBackupRepositories
func NewListBackupRepositoriesRequest(server string, params *ListBackupRepositoriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/backup-repositories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DatabaseId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "database_id", runtime.ParamLocationQuery, *params.DatabaseId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_after", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_before", runtime.ParamLocationQuery, *params.CreatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Descending != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "descending", runtime.ParamLocationQuery, *params.Descending); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBackupRepositoryInfoRequest generates requests for GetBackupRepositoryInfo
func NewGetBackupRepositoryInfoRequest(server string, id string, nodeName string, params *GetBackupRepositoryInfoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "node_name", runtime.ParamLocationPath, nodeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/backup-repositories/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BackupLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backup_limit", runtime.ParamLocationQuery, *params.BackupLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BackupOffset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backup_offset", runtime.ParamLocationQuery, *params.BackupOffset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BackupType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backup_type", runtime.ParamLocationQuery, *params.BackupType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Descending != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "descending", runtime.ParamLocationQuery, *params.Descending); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBackupStoresRequest generates requests for ListBackupStores
func NewListBackupStoresRequest(server string, params *ListBackupStoresParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/backup-stores")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_after", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_before", runtime.ParamLocationQuery, *params.CreatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Descending != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "descending", runtime.ParamLocationQuery, *params.Descending); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBackupStoreRequest calls the generic CreateBackupStore builder with application/json body
func NewCreateBackupStoreRequest(server string, body CreateBackupStoreJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBackupStoreRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateBackupStoreRequestWithBody generates requests for CreateBackupStore with any type of body
func NewCreateBackupStoreRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/backup-stores")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBackupStoreRequest generates requests for DeleteBackupStore
func NewDeleteBackupStoreRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/backup-stores/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBackupStoreRequest generates requests for GetBackupStore
func NewGetBackupStoreRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/backup-stores/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBackupsRequest generates requests for ListBackups
func NewListBackupsRequest(server string, params *ListBackupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/backups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DatabaseId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "database_id", runtime.ParamLocationQuery, *params.DatabaseId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Kind != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kind", runtime.ParamLocationQuery, *params.Kind); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_after", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_before", runtime.ParamLocationQuery, *params.CreatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Descending != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "descending", runtime.ParamLocationQuery, *params.Descending); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteBackupRequest generates requests for DeleteBackup
func NewDeleteBackupRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/backups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBackupRequest generates requests for GetBackup
func NewGetBackupRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/backups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBackupLinkRequest generates requests for GetBackupLink
func NewGetBackupLinkRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/backups/%s/url", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListClientsRequest generates requests for ListClients
func NewListClientsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clients")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateClientRequest calls the generic CreateClient builder with application/json body
func NewCreateClientRequest(server string, body CreateClientJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClientRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateClientRequestWithBody generates requests for CreateClient with any type of body
func NewCreateClientRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clients")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteClientRequest generates requests for DeleteClient
func NewDeleteClientRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clients/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClientRequest generates requests for GetClient
func NewGetClientRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clients/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateClientRequest calls the generic UpdateClient builder with application/json body
func NewUpdateClientRequest(server string, id string, body UpdateClientJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateClientRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateClientRequestWithBody generates requests for UpdateClient with any type of body
func NewUpdateClientRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clients/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListCloudAccountsRequest generates requests for ListCloudAccounts
func NewListCloudAccountsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cloud-accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCloudAccountRequest calls the generic CreateCloudAccount builder with application/json body
func NewCreateCloudAccountRequest(server string, body CreateCloudAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCloudAccountRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateCloudAccountRequestWithBody generates requests for CreateCloudAccount with any type of body
func NewCreateCloudAccountRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cloud-accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCloudAccountRequest generates requests for DeleteCloudAccount
func NewDeleteCloudAccountRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cloud-accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCloudAccountRequest generates requests for GetCloudAccount
func NewGetCloudAccountRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cloud-accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListClustersRequest generates requests for ListClusters
func NewListClustersRequest(server string, params *ListClustersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_after", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_before", runtime.ParamLocationQuery, *params.CreatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Descending != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "descending", runtime.ParamLocationQuery, *params.Descending); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateClusterRequest calls the generic CreateCluster builder with application/json body
func NewCreateClusterRequest(server string, body CreateClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClusterRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateClusterRequestWithBody generates requests for CreateCluster with any type of body
func NewCreateClusterRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteClusterRequest generates requests for DeleteCluster
func NewDeleteClusterRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClusterRequest generates requests for GetCluster
func NewGetClusterRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateClusterRequest calls the generic UpdateCluster builder with application/json body
func NewUpdateClusterRequest(server string, id string, body UpdateClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateClusterRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateClusterRequestWithBody generates requests for UpdateCluster with any type of body
func NewUpdateClusterRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadClusterMetricsRequest generates requests for ReadClusterMetrics
func NewReadClusterMetricsRequest(server string, id string, params *ReadClusterMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/metrics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListClusterNodesRequest generates requests for ListClusterNodes
func NewListClusterNodesRequest(server string, id string, params *ListClusterNodesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/nodes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NearLat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "near_lat", runtime.ParamLocationQuery, *params.NearLat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NearLon != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "near_lon", runtime.ParamLocationQuery, *params.NearLon); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClusterLogsRequest generates requests for GetClusterLogs
func NewGetClusterLogsRequest(server string, id string, nodeId string, logName string, params *GetClusterLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "node_id", runtime.ParamLocationPath, nodeId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "log_name", runtime.ParamLocationPath, logName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/nodes/%s/logs/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Lines != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lines", runtime.ParamLocationQuery, *params.Lines); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Since != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Until != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, *params.Until); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Priority != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "priority", runtime.ParamLocationQuery, *params.Priority); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Grep != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "grep", runtime.ParamLocationQuery, *params.Grep); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CaseSensitive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "case_sensitive", runtime.ParamLocationQuery, *params.CaseSensitive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reverse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reverse", runtime.ParamLocationQuery, *params.Reverse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Dmesg != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dmesg", runtime.ParamLocationQuery, *params.Dmesg); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Output != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "output", runtime.ParamLocationQuery, *params.Output); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListClusterSharesRequest generates requests for ListClusterShares
func NewListClusterSharesRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/shares", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateClusterShareRequest calls the generic CreateClusterShare builder with application/json body
func NewCreateClusterShareRequest(server string, id string, body CreateClusterShareJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClusterShareRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateClusterShareRequestWithBody generates requests for CreateClusterShare with any type of body
func NewCreateClusterShareRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/shares", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteClusterShareRequest generates requests for DeleteClusterShare
func NewDeleteClusterShareRequest(server string, id string, shareId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "share_id", runtime.ParamLocationPath, shareId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/shares/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadClusterShareRequest generates requests for ReadClusterShare
func NewReadClusterShareRequest(server string, id string, shareId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "share_id", runtime.ParamLocationPath, shareId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/shares/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListConfigVersionsRequest generates requests for ListConfigVersions
func NewListConfigVersionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/config-versions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigVersionRequest generates requests for GetConfigVersion
func NewGetConfigVersionRequest(server string, version string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/config-versions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDatabasesRequest generates requests for ListDatabases
func NewListDatabasesRequest(server string, params *ListDatabasesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ClusterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cluster_id", runtime.ParamLocationQuery, *params.ClusterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_after", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_before", runtime.ParamLocationQuery, *params.CreatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Descending != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "descending", runtime.ParamLocationQuery, *params.Descending); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDatabaseRequest calls the generic CreateDatabase builder with application/json body
func NewCreateDatabaseRequest(server string, body CreateDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDatabaseRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDatabaseRequestWithBody generates requests for CreateDatabase with any type of body
func NewCreateDatabaseRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDatabaseRequest generates requests for DeleteDatabase
func NewDeleteDatabaseRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDatabaseRequest generates requests for GetDatabase
func NewGetDatabaseRequest(server string, id string, params *GetDatabaseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_type", runtime.ParamLocationQuery, *params.UserType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDatabaseRequest calls the generic UpdateDatabase builder with application/json body
func NewUpdateDatabaseRequest(server string, id string, body UpdateDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDatabaseRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateDatabaseRequestWithBody generates requests for UpdateDatabase with any type of body
func NewUpdateDatabaseRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBackupDatabaseRequest calls the generic BackupDatabase builder with application/json body
func NewBackupDatabaseRequest(server string, id string, body BackupDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBackupDatabaseRequestWithBody(server, id, "application/json", bodyReader)
}

// NewBackupDatabaseRequestWithBody generates requests for BackupDatabase with any type of body
func NewBackupDatabaseRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/%s/backup", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDatabaseLogsRequest generates requests for GetDatabaseLogs
func NewGetDatabaseLogsRequest(server string, id string, params *GetDatabaseLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "component_name", runtime.ParamLocationQuery, params.ComponentName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.MaxLines != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_lines", runtime.ParamLocationQuery, *params.MaxLines); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nodes", runtime.ParamLocationQuery, params.Nodes); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDatabaseMetricsRequest generates requests for GetDatabaseMetrics
func NewGetDatabaseMetricsRequest(server string, id string, params *GetDatabaseMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/%s/metrics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Interval != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "interval", runtime.ParamLocationQuery, *params.Interval); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NodeName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "node_name", runtime.ParamLocationQuery, *params.NodeName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Columns != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "columns", runtime.ParamLocationQuery, *params.Columns); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplicateDatabaseRequest generates requests for ReplicateDatabase
func NewReplicateDatabaseRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/%s/replicate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreDatabaseRequest calls the generic RestoreDatabase builder with application/json body
func NewRestoreDatabaseRequest(server string, id string, body RestoreDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRestoreDatabaseRequestWithBody(server, id, "application/json", bodyReader)
}

// NewRestoreDatabaseRequestWithBody generates requests for RestoreDatabase with any type of body
func NewRestoreDatabaseRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/%s/restore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRotateDatabaseRolePasswordRequest generates requests for RotateDatabaseRolePassword
func NewRotateDatabaseRolePasswordRequest(server string, id string, roleName RotateDatabaseRolePasswordParamsRoleName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "role_name", runtime.ParamLocationPath, roleName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/%s/roles/%s/rotate-password", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryDatabaseTableRequest generates requests for QueryDatabaseTable
func NewQueryDatabaseTableRequest(server string, id string, params *QueryDatabaseTableParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/databases/%s/table-query", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "table", runtime.ParamLocationQuery, params.Table); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Schema != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schema", runtime.ParamLocationQuery, *params.Schema); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Descending != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "descending", runtime.ParamLocationQuery, *params.Descending); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListInvitesRequest generates requests for ListInvites
func NewListInvitesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/invites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateInviteRequest calls the generic CreateInvite builder with application/json body
func NewCreateInviteRequest(server string, body CreateInviteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateInviteRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateInviteRequestWithBody generates requests for CreateInvite with any type of body
func NewCreateInviteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/invites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteInviteRequest generates requests for DeleteInvite
func NewDeleteInviteRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/invites/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInviteRequest generates requests for GetInvite
func NewGetInviteRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/invites/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAcceptInviteRequest generates requests for AcceptInvite
func NewAcceptInviteRequest(server string, id string, params *AcceptInviteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/invites/%s/accept", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "invite_token", runtime.ParamLocationQuery, params.InviteToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMembershipsRequest generates requests for ListMemberships
func NewListMembershipsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/memberships")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteMembershipRequest generates requests for DeleteMembership
func NewDeleteMembershipRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/memberships/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenerateAccessTokenRequest calls the generic GenerateAccessToken builder with application/json body
func NewGenerateAccessTokenRequest(server string, body GenerateAccessTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenerateAccessTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewGenerateAccessTokenRequestWithFormdataBody calls the generic GenerateAccessToken builder with application/x-www-form-urlencoded body
func NewGenerateAccessTokenRequestWithFormdataBody(server string, body GenerateAccessTokenFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewGenerateAccessTokenRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewGenerateAccessTokenRequestWithBody generates requests for GenerateAccessToken with any type of body
func NewGenerateAccessTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oauth/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOpenApiSpecRequest generates requests for GetOpenApiSpec
func NewGetOpenApiSpecRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/open-api")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSshKeysRequest generates requests for ListSshKeys
func NewListSshKeysRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ssh-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSshKeyRequest calls the generic CreateSshKey builder with application/json body
func NewCreateSshKeyRequest(server string, body CreateSshKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSshKeyRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSshKeyRequestWithBody generates requests for CreateSshKey with any type of body
func NewCreateSshKeyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ssh-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSshKeyRequest generates requests for DeleteSshKey
func NewDeleteSshKeyRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ssh-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSshKeyRequest generates requests for GetSshKey
func NewGetSshKeyRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ssh-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTasksRequest generates requests for ListTasks
func NewListTasksRequest(server string, params *ListTasksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SubjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subject_id", runtime.ParamLocationQuery, *params.SubjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubjectKind != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subject_kind", runtime.ParamLocationQuery, *params.SubjectKind); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCloudFormationTemplateRequest generates requests for GetCloudFormationTemplate
func NewGetCloudFormationTemplateRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/permissions/cloudformation")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTenantsRequest generates requests for ListTenants
func NewListTenantsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTenantRequest generates requests for GetTenant
func NewGetTenantRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTenantRequest calls the generic UpdateTenant builder with application/json body
func NewUpdateTenantRequest(server string, id string, body UpdateTenantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTenantRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateTenantRequestWithBody generates requests for UpdateTenant with any type of body
func NewUpdateTenantRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCurrentUserRequest generates requests for GetCurrentUser
func NewGetCurrentUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/me")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCurrentUserRequest calls the generic UpdateCurrentUser builder with application/json body
func NewUpdateCurrentUserRequest(server string, body UpdateCurrentUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCurrentUserRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateCurrentUserRequestWithBody generates requests for UpdateCurrentUser with any type of body
func NewUpdateCurrentUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/me")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListAvailableClustersWithResponse request
	ListAvailableClustersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAvailableClustersResponse, error)

	// ListBackupRepositoriesWithResponse request
	ListBackupRepositoriesWithResponse(ctx context.Context, params *ListBackupRepositoriesParams, reqEditors ...RequestEditorFn) (*ListBackupRepositoriesResponse, error)

	// GetBackupRepositoryInfoWithResponse request
	GetBackupRepositoryInfoWithResponse(ctx context.Context, id string, nodeName string, params *GetBackupRepositoryInfoParams, reqEditors ...RequestEditorFn) (*GetBackupRepositoryInfoResponse, error)

	// ListBackupStoresWithResponse request
	ListBackupStoresWithResponse(ctx context.Context, params *ListBackupStoresParams, reqEditors ...RequestEditorFn) (*ListBackupStoresResponse, error)

	// CreateBackupStoreWithBodyWithResponse request with any body
	CreateBackupStoreWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBackupStoreResponse, error)

	CreateBackupStoreWithResponse(ctx context.Context, body CreateBackupStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBackupStoreResponse, error)

	// DeleteBackupStoreWithResponse request
	DeleteBackupStoreWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteBackupStoreResponse, error)

	// GetBackupStoreWithResponse request
	GetBackupStoreWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetBackupStoreResponse, error)

	// ListBackupsWithResponse request
	ListBackupsWithResponse(ctx context.Context, params *ListBackupsParams, reqEditors ...RequestEditorFn) (*ListBackupsResponse, error)

	// DeleteBackupWithResponse request
	DeleteBackupWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteBackupResponse, error)

	// GetBackupWithResponse request
	GetBackupWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetBackupResponse, error)

	// GetBackupLinkWithResponse request
	GetBackupLinkWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetBackupLinkResponse, error)

	// ListClientsWithResponse request
	ListClientsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListClientsResponse, error)

	// CreateClientWithBodyWithResponse request with any body
	CreateClientWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientResponse, error)

	CreateClientWithResponse(ctx context.Context, body CreateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientResponse, error)

	// DeleteClientWithResponse request
	DeleteClientWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteClientResponse, error)

	// GetClientWithResponse request
	GetClientWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetClientResponse, error)

	// UpdateClientWithBodyWithResponse request with any body
	UpdateClientWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClientResponse, error)

	UpdateClientWithResponse(ctx context.Context, id string, body UpdateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClientResponse, error)

	// ListCloudAccountsWithResponse request
	ListCloudAccountsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListCloudAccountsResponse, error)

	// CreateCloudAccountWithBodyWithResponse request with any body
	CreateCloudAccountWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCloudAccountResponse, error)

	CreateCloudAccountWithResponse(ctx context.Context, body CreateCloudAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCloudAccountResponse, error)

	// DeleteCloudAccountWithResponse request
	DeleteCloudAccountWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteCloudAccountResponse, error)

	// GetCloudAccountWithResponse request
	GetCloudAccountWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetCloudAccountResponse, error)

	// ListClustersWithResponse request
	ListClustersWithResponse(ctx context.Context, params *ListClustersParams, reqEditors ...RequestEditorFn) (*ListClustersResponse, error)

	// CreateClusterWithBodyWithResponse request with any body
	CreateClusterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error)

	CreateClusterWithResponse(ctx context.Context, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error)

	// DeleteClusterWithResponse request
	DeleteClusterWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteClusterResponse, error)

	// GetClusterWithResponse request
	GetClusterWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetClusterResponse, error)

	// UpdateClusterWithBodyWithResponse request with any body
	UpdateClusterWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error)

	UpdateClusterWithResponse(ctx context.Context, id string, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error)

	// ReadClusterMetricsWithResponse request
	ReadClusterMetricsWithResponse(ctx context.Context, id string, params *ReadClusterMetricsParams, reqEditors ...RequestEditorFn) (*ReadClusterMetricsResponse, error)

	// ListClusterNodesWithResponse request
	ListClusterNodesWithResponse(ctx context.Context, id string, params *ListClusterNodesParams, reqEditors ...RequestEditorFn) (*ListClusterNodesResponse, error)

	// GetClusterLogsWithResponse request
	GetClusterLogsWithResponse(ctx context.Context, id string, nodeId string, logName string, params *GetClusterLogsParams, reqEditors ...RequestEditorFn) (*GetClusterLogsResponse, error)

	// ListClusterSharesWithResponse request
	ListClusterSharesWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ListClusterSharesResponse, error)

	// CreateClusterShareWithBodyWithResponse request with any body
	CreateClusterShareWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterShareResponse, error)

	CreateClusterShareWithResponse(ctx context.Context, id string, body CreateClusterShareJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterShareResponse, error)

	// DeleteClusterShareWithResponse request
	DeleteClusterShareWithResponse(ctx context.Context, id string, shareId string, reqEditors ...RequestEditorFn) (*DeleteClusterShareResponse, error)

	// ReadClusterShareWithResponse request
	ReadClusterShareWithResponse(ctx context.Context, id string, shareId string, reqEditors ...RequestEditorFn) (*ReadClusterShareResponse, error)

	// ListConfigVersionsWithResponse request
	ListConfigVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListConfigVersionsResponse, error)

	// GetConfigVersionWithResponse request
	GetConfigVersionWithResponse(ctx context.Context, version string, reqEditors ...RequestEditorFn) (*GetConfigVersionResponse, error)

	// ListDatabasesWithResponse request
	ListDatabasesWithResponse(ctx context.Context, params *ListDatabasesParams, reqEditors ...RequestEditorFn) (*ListDatabasesResponse, error)

	// CreateDatabaseWithBodyWithResponse request with any body
	CreateDatabaseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatabaseResponse, error)

	CreateDatabaseWithResponse(ctx context.Context, body CreateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatabaseResponse, error)

	// DeleteDatabaseWithResponse request
	DeleteDatabaseWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteDatabaseResponse, error)

	// GetDatabaseWithResponse request
	GetDatabaseWithResponse(ctx context.Context, id string, params *GetDatabaseParams, reqEditors ...RequestEditorFn) (*GetDatabaseResponse, error)

	// UpdateDatabaseWithBodyWithResponse request with any body
	UpdateDatabaseWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDatabaseResponse, error)

	UpdateDatabaseWithResponse(ctx context.Context, id string, body UpdateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDatabaseResponse, error)

	// BackupDatabaseWithBodyWithResponse request with any body
	BackupDatabaseWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BackupDatabaseResponse, error)

	BackupDatabaseWithResponse(ctx context.Context, id string, body BackupDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*BackupDatabaseResponse, error)

	// GetDatabaseLogsWithResponse request
	GetDatabaseLogsWithResponse(ctx context.Context, id string, params *GetDatabaseLogsParams, reqEditors ...RequestEditorFn) (*GetDatabaseLogsResponse, error)

	// GetDatabaseMetricsWithResponse request
	GetDatabaseMetricsWithResponse(ctx context.Context, id string, params *GetDatabaseMetricsParams, reqEditors ...RequestEditorFn) (*GetDatabaseMetricsResponse, error)

	// ReplicateDatabaseWithResponse request
	ReplicateDatabaseWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReplicateDatabaseResponse, error)

	// RestoreDatabaseWithBodyWithResponse request with any body
	RestoreDatabaseWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestoreDatabaseResponse, error)

	RestoreDatabaseWithResponse(ctx context.Context, id string, body RestoreDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*RestoreDatabaseResponse, error)

	// RotateDatabaseRolePasswordWithResponse request
	RotateDatabaseRolePasswordWithResponse(ctx context.Context, id string, roleName RotateDatabaseRolePasswordParamsRoleName, reqEditors ...RequestEditorFn) (*RotateDatabaseRolePasswordResponse, error)

	// QueryDatabaseTableWithResponse request
	QueryDatabaseTableWithResponse(ctx context.Context, id string, params *QueryDatabaseTableParams, reqEditors ...RequestEditorFn) (*QueryDatabaseTableResponse, error)

	// ListInvitesWithResponse request
	ListInvitesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListInvitesResponse, error)

	// CreateInviteWithBodyWithResponse request with any body
	CreateInviteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateInviteResponse, error)

	CreateInviteWithResponse(ctx context.Context, body CreateInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateInviteResponse, error)

	// DeleteInviteWithResponse request
	DeleteInviteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteInviteResponse, error)

	// GetInviteWithResponse request
	GetInviteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetInviteResponse, error)

	// AcceptInviteWithResponse request
	AcceptInviteWithResponse(ctx context.Context, id string, params *AcceptInviteParams, reqEditors ...RequestEditorFn) (*AcceptInviteResponse, error)

	// ListMembershipsWithResponse request
	ListMembershipsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListMembershipsResponse, error)

	// DeleteMembershipWithResponse request
	DeleteMembershipWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteMembershipResponse, error)

	// GenerateAccessTokenWithBodyWithResponse request with any body
	GenerateAccessTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateAccessTokenResponse, error)

	GenerateAccessTokenWithResponse(ctx context.Context, body GenerateAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateAccessTokenResponse, error)

	GenerateAccessTokenWithFormdataBodyWithResponse(ctx context.Context, body GenerateAccessTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*GenerateAccessTokenResponse, error)

	// GetOpenApiSpecWithResponse request
	GetOpenApiSpecWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenApiSpecResponse, error)

	// ListSshKeysWithResponse request
	ListSshKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSshKeysResponse, error)

	// CreateSshKeyWithBodyWithResponse request with any body
	CreateSshKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSshKeyResponse, error)

	CreateSshKeyWithResponse(ctx context.Context, body CreateSshKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSshKeyResponse, error)

	// DeleteSshKeyWithResponse request
	DeleteSshKeyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSshKeyResponse, error)

	// GetSshKeyWithResponse request
	GetSshKeyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSshKeyResponse, error)

	// ListTasksWithResponse request
	ListTasksWithResponse(ctx context.Context, params *ListTasksParams, reqEditors ...RequestEditorFn) (*ListTasksResponse, error)

	// GetCloudFormationTemplateWithResponse request
	GetCloudFormationTemplateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCloudFormationTemplateResponse, error)

	// ListTenantsWithResponse request
	ListTenantsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListTenantsResponse, error)

	// GetTenantWithResponse request
	GetTenantWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetTenantResponse, error)

	// UpdateTenantWithBodyWithResponse request with any body
	UpdateTenantWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTenantResponse, error)

	UpdateTenantWithResponse(ctx context.Context, id string, body UpdateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTenantResponse, error)

	// GetCurrentUserWithResponse request
	GetCurrentUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentUserResponse, error)

	// UpdateCurrentUserWithBodyWithResponse request with any body
	UpdateCurrentUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCurrentUserResponse, error)

	UpdateCurrentUserWithResponse(ctx context.Context, body UpdateCurrentUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCurrentUserResponse, error)
}

type ListAvailableClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AvailableCluster
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListAvailableClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAvailableClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBackupRepositoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]BackupRepository
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListBackupRepositoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBackupRepositoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBackupRepositoryInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PgBackrestRepositoryInfo
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetBackupRepositoryInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBackupRepositoryInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBackupStoresResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]BackupStore
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListBackupStoresResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBackupStoresResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBackupStoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BackupStore
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateBackupStoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBackupStoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBackupStoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteBackupStoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBackupStoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBackupStoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BackupStore
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetBackupStoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBackupStoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBackupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Backup
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListBackupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBackupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBackupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteBackupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBackupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBackupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Backup
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetBackupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBackupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBackupLinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BackupLink
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetBackupLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBackupLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListClientsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ApiClient
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListClientsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClientsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiClient
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiClient
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiClient
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdateClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCloudAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CloudAccount
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListCloudAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCloudAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCloudAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CloudAccount
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateCloudAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCloudAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCloudAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteCloudAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCloudAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCloudAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CloudAccount
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetCloudAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCloudAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Cluster
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Cluster
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Cluster
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Cluster
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdateClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadClusterMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Metrics
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ReadClusterMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadClusterMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListClusterNodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ClusterNode
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListClusterNodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClusterNodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ClusterNodeLogMessage
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetClusterLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListClusterSharesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ClusterShare
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListClusterSharesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClusterSharesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClusterShareResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterShare
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateClusterShareResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClusterShareResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClusterShareResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteClusterShareResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClusterShareResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadClusterShareResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterShare
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ReadClusterShareResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadClusterShareResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListConfigVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ConfigVersion
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListConfigVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListConfigVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConfigVersion
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetConfigVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDatabasesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Database
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListDatabasesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDatabasesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Database
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Database
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Database
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdateDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BackupDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r BackupDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BackupDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDatabaseLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]DatabaseLogsResponse
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetDatabaseLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatabaseLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDatabaseMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetricSeriesContainer
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetDatabaseMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatabaseMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplicateDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ReplicateDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplicateDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r RestoreDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RotateDatabaseRolePasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r RotateDatabaseRolePasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RotateDatabaseRolePasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryDatabaseTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TableQueryResponse
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r QueryDatabaseTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryDatabaseTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInvitesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Invite
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListInvitesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInvitesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateInviteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Invite
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateInviteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateInviteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInviteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteInviteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInviteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInviteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Invite
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetInviteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInviteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AcceptInviteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AcceptInviteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AcceptInviteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMembershipsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Membership
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListMembershipsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMembershipsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMembershipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteMembershipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMembershipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateAccessTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccessToken
	JSON400      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GenerateAccessTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateAccessTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOpenApiSpecResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OpenApiSpec
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetOpenApiSpecResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOpenApiSpecResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSshKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SshKey
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListSshKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSshKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSshKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SshKey
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateSshKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSshKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSshKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteSshKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSshKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSshKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SshKey
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSshKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSshKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Task
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCloudFormationTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CloudFormationTemplate
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetCloudFormationTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCloudFormationTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTenantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Tenant
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListTenantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTenantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTenantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Tenant
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTenantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Tenant
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdateTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]User
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetCurrentUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCurrentUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdateCurrentUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCurrentUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListAvailableClustersWithResponse request returning *ListAvailableClustersResponse
func (c *ClientWithResponses) ListAvailableClustersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAvailableClustersResponse, error) {
	rsp, err := c.ListAvailableClusters(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAvailableClustersResponse(rsp)
}

// ListBackupRepositoriesWithResponse request returning *ListBackupRepositoriesResponse
func (c *ClientWithResponses) ListBackupRepositoriesWithResponse(ctx context.Context, params *ListBackupRepositoriesParams, reqEditors ...RequestEditorFn) (*ListBackupRepositoriesResponse, error) {
	rsp, err := c.ListBackupRepositories(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBackupRepositoriesResponse(rsp)
}

// GetBackupRepositoryInfoWithResponse request returning *GetBackupRepositoryInfoResponse
func (c *ClientWithResponses) GetBackupRepositoryInfoWithResponse(ctx context.Context, id string, nodeName string, params *GetBackupRepositoryInfoParams, reqEditors ...RequestEditorFn) (*GetBackupRepositoryInfoResponse, error) {
	rsp, err := c.GetBackupRepositoryInfo(ctx, id, nodeName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBackupRepositoryInfoResponse(rsp)
}

// ListBackupStoresWithResponse request returning *ListBackupStoresResponse
func (c *ClientWithResponses) ListBackupStoresWithResponse(ctx context.Context, params *ListBackupStoresParams, reqEditors ...RequestEditorFn) (*ListBackupStoresResponse, error) {
	rsp, err := c.ListBackupStores(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBackupStoresResponse(rsp)
}

// CreateBackupStoreWithBodyWithResponse request with arbitrary body returning *CreateBackupStoreResponse
func (c *ClientWithResponses) CreateBackupStoreWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBackupStoreResponse, error) {
	rsp, err := c.CreateBackupStoreWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBackupStoreResponse(rsp)
}

func (c *ClientWithResponses) CreateBackupStoreWithResponse(ctx context.Context, body CreateBackupStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBackupStoreResponse, error) {
	rsp, err := c.CreateBackupStore(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBackupStoreResponse(rsp)
}

// DeleteBackupStoreWithResponse request returning *DeleteBackupStoreResponse
func (c *ClientWithResponses) DeleteBackupStoreWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteBackupStoreResponse, error) {
	rsp, err := c.DeleteBackupStore(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBackupStoreResponse(rsp)
}

// GetBackupStoreWithResponse request returning *GetBackupStoreResponse
func (c *ClientWithResponses) GetBackupStoreWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetBackupStoreResponse, error) {
	rsp, err := c.GetBackupStore(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBackupStoreResponse(rsp)
}

// ListBackupsWithResponse request returning *ListBackupsResponse
func (c *ClientWithResponses) ListBackupsWithResponse(ctx context.Context, params *ListBackupsParams, reqEditors ...RequestEditorFn) (*ListBackupsResponse, error) {
	rsp, err := c.ListBackups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBackupsResponse(rsp)
}

// DeleteBackupWithResponse request returning *DeleteBackupResponse
func (c *ClientWithResponses) DeleteBackupWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteBackupResponse, error) {
	rsp, err := c.DeleteBackup(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBackupResponse(rsp)
}

// GetBackupWithResponse request returning *GetBackupResponse
func (c *ClientWithResponses) GetBackupWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetBackupResponse, error) {
	rsp, err := c.GetBackup(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBackupResponse(rsp)
}

// GetBackupLinkWithResponse request returning *GetBackupLinkResponse
func (c *ClientWithResponses) GetBackupLinkWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetBackupLinkResponse, error) {
	rsp, err := c.GetBackupLink(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBackupLinkResponse(rsp)
}

// ListClientsWithResponse request returning *ListClientsResponse
func (c *ClientWithResponses) ListClientsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListClientsResponse, error) {
	rsp, err := c.ListClients(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClientsResponse(rsp)
}

// CreateClientWithBodyWithResponse request with arbitrary body returning *CreateClientResponse
func (c *ClientWithResponses) CreateClientWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientResponse, error) {
	rsp, err := c.CreateClientWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientResponse(rsp)
}

func (c *ClientWithResponses) CreateClientWithResponse(ctx context.Context, body CreateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientResponse, error) {
	rsp, err := c.CreateClient(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientResponse(rsp)
}

// DeleteClientWithResponse request returning *DeleteClientResponse
func (c *ClientWithResponses) DeleteClientWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteClientResponse, error) {
	rsp, err := c.DeleteClient(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClientResponse(rsp)
}

// GetClientWithResponse request returning *GetClientResponse
func (c *ClientWithResponses) GetClientWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetClientResponse, error) {
	rsp, err := c.GetClient(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientResponse(rsp)
}

// UpdateClientWithBodyWithResponse request with arbitrary body returning *UpdateClientResponse
func (c *ClientWithResponses) UpdateClientWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClientResponse, error) {
	rsp, err := c.UpdateClientWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClientResponse(rsp)
}

func (c *ClientWithResponses) UpdateClientWithResponse(ctx context.Context, id string, body UpdateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClientResponse, error) {
	rsp, err := c.UpdateClient(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClientResponse(rsp)
}

// ListCloudAccountsWithResponse request returning *ListCloudAccountsResponse
func (c *ClientWithResponses) ListCloudAccountsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListCloudAccountsResponse, error) {
	rsp, err := c.ListCloudAccounts(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCloudAccountsResponse(rsp)
}

// CreateCloudAccountWithBodyWithResponse request with arbitrary body returning *CreateCloudAccountResponse
func (c *ClientWithResponses) CreateCloudAccountWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCloudAccountResponse, error) {
	rsp, err := c.CreateCloudAccountWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCloudAccountResponse(rsp)
}

func (c *ClientWithResponses) CreateCloudAccountWithResponse(ctx context.Context, body CreateCloudAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCloudAccountResponse, error) {
	rsp, err := c.CreateCloudAccount(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCloudAccountResponse(rsp)
}

// DeleteCloudAccountWithResponse request returning *DeleteCloudAccountResponse
func (c *ClientWithResponses) DeleteCloudAccountWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteCloudAccountResponse, error) {
	rsp, err := c.DeleteCloudAccount(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCloudAccountResponse(rsp)
}

// GetCloudAccountWithResponse request returning *GetCloudAccountResponse
func (c *ClientWithResponses) GetCloudAccountWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetCloudAccountResponse, error) {
	rsp, err := c.GetCloudAccount(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCloudAccountResponse(rsp)
}

// ListClustersWithResponse request returning *ListClustersResponse
func (c *ClientWithResponses) ListClustersWithResponse(ctx context.Context, params *ListClustersParams, reqEditors ...RequestEditorFn) (*ListClustersResponse, error) {
	rsp, err := c.ListClusters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClustersResponse(rsp)
}

// CreateClusterWithBodyWithResponse request with arbitrary body returning *CreateClusterResponse
func (c *ClientWithResponses) CreateClusterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error) {
	rsp, err := c.CreateClusterWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterResponse(rsp)
}

func (c *ClientWithResponses) CreateClusterWithResponse(ctx context.Context, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error) {
	rsp, err := c.CreateCluster(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterResponse(rsp)
}

// DeleteClusterWithResponse request returning *DeleteClusterResponse
func (c *ClientWithResponses) DeleteClusterWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteClusterResponse, error) {
	rsp, err := c.DeleteCluster(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClusterResponse(rsp)
}

// GetClusterWithResponse request returning *GetClusterResponse
func (c *ClientWithResponses) GetClusterWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetClusterResponse, error) {
	rsp, err := c.GetCluster(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterResponse(rsp)
}

// UpdateClusterWithBodyWithResponse request with arbitrary body returning *UpdateClusterResponse
func (c *ClientWithResponses) UpdateClusterWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error) {
	rsp, err := c.UpdateClusterWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterResponse(rsp)
}

func (c *ClientWithResponses) UpdateClusterWithResponse(ctx context.Context, id string, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error) {
	rsp, err := c.UpdateCluster(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterResponse(rsp)
}

// ReadClusterMetricsWithResponse request returning *ReadClusterMetricsResponse
func (c *ClientWithResponses) ReadClusterMetricsWithResponse(ctx context.Context, id string, params *ReadClusterMetricsParams, reqEditors ...RequestEditorFn) (*ReadClusterMetricsResponse, error) {
	rsp, err := c.ReadClusterMetrics(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadClusterMetricsResponse(rsp)
}

// ListClusterNodesWithResponse request returning *ListClusterNodesResponse
func (c *ClientWithResponses) ListClusterNodesWithResponse(ctx context.Context, id string, params *ListClusterNodesParams, reqEditors ...RequestEditorFn) (*ListClusterNodesResponse, error) {
	rsp, err := c.ListClusterNodes(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClusterNodesResponse(rsp)
}

// GetClusterLogsWithResponse request returning *GetClusterLogsResponse
func (c *ClientWithResponses) GetClusterLogsWithResponse(ctx context.Context, id string, nodeId string, logName string, params *GetClusterLogsParams, reqEditors ...RequestEditorFn) (*GetClusterLogsResponse, error) {
	rsp, err := c.GetClusterLogs(ctx, id, nodeId, logName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterLogsResponse(rsp)
}

// ListClusterSharesWithResponse request returning *ListClusterSharesResponse
func (c *ClientWithResponses) ListClusterSharesWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ListClusterSharesResponse, error) {
	rsp, err := c.ListClusterShares(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClusterSharesResponse(rsp)
}

// CreateClusterShareWithBodyWithResponse request with arbitrary body returning *CreateClusterShareResponse
func (c *ClientWithResponses) CreateClusterShareWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterShareResponse, error) {
	rsp, err := c.CreateClusterShareWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterShareResponse(rsp)
}

func (c *ClientWithResponses) CreateClusterShareWithResponse(ctx context.Context, id string, body CreateClusterShareJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterShareResponse, error) {
	rsp, err := c.CreateClusterShare(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterShareResponse(rsp)
}

// DeleteClusterShareWithResponse request returning *DeleteClusterShareResponse
func (c *ClientWithResponses) DeleteClusterShareWithResponse(ctx context.Context, id string, shareId string, reqEditors ...RequestEditorFn) (*DeleteClusterShareResponse, error) {
	rsp, err := c.DeleteClusterShare(ctx, id, shareId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClusterShareResponse(rsp)
}

// ReadClusterShareWithResponse request returning *ReadClusterShareResponse
func (c *ClientWithResponses) ReadClusterShareWithResponse(ctx context.Context, id string, shareId string, reqEditors ...RequestEditorFn) (*ReadClusterShareResponse, error) {
	rsp, err := c.ReadClusterShare(ctx, id, shareId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadClusterShareResponse(rsp)
}

// ListConfigVersionsWithResponse request returning *ListConfigVersionsResponse
func (c *ClientWithResponses) ListConfigVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListConfigVersionsResponse, error) {
	rsp, err := c.ListConfigVersions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListConfigVersionsResponse(rsp)
}

// GetConfigVersionWithResponse request returning *GetConfigVersionResponse
func (c *ClientWithResponses) GetConfigVersionWithResponse(ctx context.Context, version string, reqEditors ...RequestEditorFn) (*GetConfigVersionResponse, error) {
	rsp, err := c.GetConfigVersion(ctx, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigVersionResponse(rsp)
}

// ListDatabasesWithResponse request returning *ListDatabasesResponse
func (c *ClientWithResponses) ListDatabasesWithResponse(ctx context.Context, params *ListDatabasesParams, reqEditors ...RequestEditorFn) (*ListDatabasesResponse, error) {
	rsp, err := c.ListDatabases(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDatabasesResponse(rsp)
}

// CreateDatabaseWithBodyWithResponse request with arbitrary body returning *CreateDatabaseResponse
func (c *ClientWithResponses) CreateDatabaseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatabaseResponse, error) {
	rsp, err := c.CreateDatabaseWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabaseResponse(rsp)
}

func (c *ClientWithResponses) CreateDatabaseWithResponse(ctx context.Context, body CreateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatabaseResponse, error) {
	rsp, err := c.CreateDatabase(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabaseResponse(rsp)
}

// DeleteDatabaseWithResponse request returning *DeleteDatabaseResponse
func (c *ClientWithResponses) DeleteDatabaseWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteDatabaseResponse, error) {
	rsp, err := c.DeleteDatabase(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDatabaseResponse(rsp)
}

// GetDatabaseWithResponse request returning *GetDatabaseResponse
func (c *ClientWithResponses) GetDatabaseWithResponse(ctx context.Context, id string, params *GetDatabaseParams, reqEditors ...RequestEditorFn) (*GetDatabaseResponse, error) {
	rsp, err := c.GetDatabase(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDatabaseResponse(rsp)
}

// UpdateDatabaseWithBodyWithResponse request with arbitrary body returning *UpdateDatabaseResponse
func (c *ClientWithResponses) UpdateDatabaseWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDatabaseResponse, error) {
	rsp, err := c.UpdateDatabaseWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDatabaseResponse(rsp)
}

func (c *ClientWithResponses) UpdateDatabaseWithResponse(ctx context.Context, id string, body UpdateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDatabaseResponse, error) {
	rsp, err := c.UpdateDatabase(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDatabaseResponse(rsp)
}

// BackupDatabaseWithBodyWithResponse request with arbitrary body returning *BackupDatabaseResponse
func (c *ClientWithResponses) BackupDatabaseWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BackupDatabaseResponse, error) {
	rsp, err := c.BackupDatabaseWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBackupDatabaseResponse(rsp)
}

func (c *ClientWithResponses) BackupDatabaseWithResponse(ctx context.Context, id string, body BackupDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*BackupDatabaseResponse, error) {
	rsp, err := c.BackupDatabase(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBackupDatabaseResponse(rsp)
}

// GetDatabaseLogsWithResponse request returning *GetDatabaseLogsResponse
func (c *ClientWithResponses) GetDatabaseLogsWithResponse(ctx context.Context, id string, params *GetDatabaseLogsParams, reqEditors ...RequestEditorFn) (*GetDatabaseLogsResponse, error) {
	rsp, err := c.GetDatabaseLogs(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDatabaseLogsResponse(rsp)
}

// GetDatabaseMetricsWithResponse request returning *GetDatabaseMetricsResponse
func (c *ClientWithResponses) GetDatabaseMetricsWithResponse(ctx context.Context, id string, params *GetDatabaseMetricsParams, reqEditors ...RequestEditorFn) (*GetDatabaseMetricsResponse, error) {
	rsp, err := c.GetDatabaseMetrics(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDatabaseMetricsResponse(rsp)
}

// ReplicateDatabaseWithResponse request returning *ReplicateDatabaseResponse
func (c *ClientWithResponses) ReplicateDatabaseWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReplicateDatabaseResponse, error) {
	rsp, err := c.ReplicateDatabase(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplicateDatabaseResponse(rsp)
}

// RestoreDatabaseWithBodyWithResponse request with arbitrary body returning *RestoreDatabaseResponse
func (c *ClientWithResponses) RestoreDatabaseWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestoreDatabaseResponse, error) {
	rsp, err := c.RestoreDatabaseWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreDatabaseResponse(rsp)
}

func (c *ClientWithResponses) RestoreDatabaseWithResponse(ctx context.Context, id string, body RestoreDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*RestoreDatabaseResponse, error) {
	rsp, err := c.RestoreDatabase(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreDatabaseResponse(rsp)
}

// RotateDatabaseRolePasswordWithResponse request returning *RotateDatabaseRolePasswordResponse
func (c *ClientWithResponses) RotateDatabaseRolePasswordWithResponse(ctx context.Context, id string, roleName RotateDatabaseRolePasswordParamsRoleName, reqEditors ...RequestEditorFn) (*RotateDatabaseRolePasswordResponse, error) {
	rsp, err := c.RotateDatabaseRolePassword(ctx, id, roleName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRotateDatabaseRolePasswordResponse(rsp)
}

// QueryDatabaseTableWithResponse request returning *QueryDatabaseTableResponse
func (c *ClientWithResponses) QueryDatabaseTableWithResponse(ctx context.Context, id string, params *QueryDatabaseTableParams, reqEditors ...RequestEditorFn) (*QueryDatabaseTableResponse, error) {
	rsp, err := c.QueryDatabaseTable(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryDatabaseTableResponse(rsp)
}

// ListInvitesWithResponse request returning *ListInvitesResponse
func (c *ClientWithResponses) ListInvitesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListInvitesResponse, error) {
	rsp, err := c.ListInvites(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInvitesResponse(rsp)
}

// CreateInviteWithBodyWithResponse request with arbitrary body returning *CreateInviteResponse
func (c *ClientWithResponses) CreateInviteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateInviteResponse, error) {
	rsp, err := c.CreateInviteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateInviteResponse(rsp)
}

func (c *ClientWithResponses) CreateInviteWithResponse(ctx context.Context, body CreateInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateInviteResponse, error) {
	rsp, err := c.CreateInvite(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateInviteResponse(rsp)
}

// DeleteInviteWithResponse request returning *DeleteInviteResponse
func (c *ClientWithResponses) DeleteInviteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteInviteResponse, error) {
	rsp, err := c.DeleteInvite(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInviteResponse(rsp)
}

// GetInviteWithResponse request returning *GetInviteResponse
func (c *ClientWithResponses) GetInviteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetInviteResponse, error) {
	rsp, err := c.GetInvite(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInviteResponse(rsp)
}

// AcceptInviteWithResponse request returning *AcceptInviteResponse
func (c *ClientWithResponses) AcceptInviteWithResponse(ctx context.Context, id string, params *AcceptInviteParams, reqEditors ...RequestEditorFn) (*AcceptInviteResponse, error) {
	rsp, err := c.AcceptInvite(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptInviteResponse(rsp)
}

// ListMembershipsWithResponse request returning *ListMembershipsResponse
func (c *ClientWithResponses) ListMembershipsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListMembershipsResponse, error) {
	rsp, err := c.ListMemberships(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMembershipsResponse(rsp)
}

// DeleteMembershipWithResponse request returning *DeleteMembershipResponse
func (c *ClientWithResponses) DeleteMembershipWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteMembershipResponse, error) {
	rsp, err := c.DeleteMembership(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMembershipResponse(rsp)
}

// GenerateAccessTokenWithBodyWithResponse request with arbitrary body returning *GenerateAccessTokenResponse
func (c *ClientWithResponses) GenerateAccessTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateAccessTokenResponse, error) {
	rsp, err := c.GenerateAccessTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateAccessTokenResponse(rsp)
}

func (c *ClientWithResponses) GenerateAccessTokenWithResponse(ctx context.Context, body GenerateAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateAccessTokenResponse, error) {
	rsp, err := c.GenerateAccessToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateAccessTokenResponse(rsp)
}

func (c *ClientWithResponses) GenerateAccessTokenWithFormdataBodyWithResponse(ctx context.Context, body GenerateAccessTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*GenerateAccessTokenResponse, error) {
	rsp, err := c.GenerateAccessTokenWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateAccessTokenResponse(rsp)
}

// GetOpenApiSpecWithResponse request returning *GetOpenApiSpecResponse
func (c *ClientWithResponses) GetOpenApiSpecWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenApiSpecResponse, error) {
	rsp, err := c.GetOpenApiSpec(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOpenApiSpecResponse(rsp)
}

// ListSshKeysWithResponse request returning *ListSshKeysResponse
func (c *ClientWithResponses) ListSshKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSshKeysResponse, error) {
	rsp, err := c.ListSshKeys(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSshKeysResponse(rsp)
}

// CreateSshKeyWithBodyWithResponse request with arbitrary body returning *CreateSshKeyResponse
func (c *ClientWithResponses) CreateSshKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSshKeyResponse, error) {
	rsp, err := c.CreateSshKeyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSshKeyResponse(rsp)
}

func (c *ClientWithResponses) CreateSshKeyWithResponse(ctx context.Context, body CreateSshKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSshKeyResponse, error) {
	rsp, err := c.CreateSshKey(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSshKeyResponse(rsp)
}

// DeleteSshKeyWithResponse request returning *DeleteSshKeyResponse
func (c *ClientWithResponses) DeleteSshKeyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSshKeyResponse, error) {
	rsp, err := c.DeleteSshKey(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSshKeyResponse(rsp)
}

// GetSshKeyWithResponse request returning *GetSshKeyResponse
func (c *ClientWithResponses) GetSshKeyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSshKeyResponse, error) {
	rsp, err := c.GetSshKey(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSshKeyResponse(rsp)
}

// ListTasksWithResponse request returning *ListTasksResponse
func (c *ClientWithResponses) ListTasksWithResponse(ctx context.Context, params *ListTasksParams, reqEditors ...RequestEditorFn) (*ListTasksResponse, error) {
	rsp, err := c.ListTasks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTasksResponse(rsp)
}

// GetCloudFormationTemplateWithResponse request returning *GetCloudFormationTemplateResponse
func (c *ClientWithResponses) GetCloudFormationTemplateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCloudFormationTemplateResponse, error) {
	rsp, err := c.GetCloudFormationTemplate(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCloudFormationTemplateResponse(rsp)
}

// ListTenantsWithResponse request returning *ListTenantsResponse
func (c *ClientWithResponses) ListTenantsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListTenantsResponse, error) {
	rsp, err := c.ListTenants(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTenantsResponse(rsp)
}

// GetTenantWithResponse request returning *GetTenantResponse
func (c *ClientWithResponses) GetTenantWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetTenantResponse, error) {
	rsp, err := c.GetTenant(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTenantResponse(rsp)
}

// UpdateTenantWithBodyWithResponse request with arbitrary body returning *UpdateTenantResponse
func (c *ClientWithResponses) UpdateTenantWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTenantResponse, error) {
	rsp, err := c.UpdateTenantWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTenantResponse(rsp)
}

func (c *ClientWithResponses) UpdateTenantWithResponse(ctx context.Context, id string, body UpdateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTenantResponse, error) {
	rsp, err := c.UpdateTenant(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTenantResponse(rsp)
}

// GetCurrentUserWithResponse request returning *GetCurrentUserResponse
func (c *ClientWithResponses) GetCurrentUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentUserResponse, error) {
	rsp, err := c.GetCurrentUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentUserResponse(rsp)
}

// UpdateCurrentUserWithBodyWithResponse request with arbitrary body returning *UpdateCurrentUserResponse
func (c *ClientWithResponses) UpdateCurrentUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCurrentUserResponse, error) {
	rsp, err := c.UpdateCurrentUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCurrentUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateCurrentUserWithResponse(ctx context.Context, body UpdateCurrentUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCurrentUserResponse, error) {
	rsp, err := c.UpdateCurrentUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCurrentUserResponse(rsp)
}

// ParseListAvailableClustersResponse parses an HTTP response from a ListAvailableClustersWithResponse call
func ParseListAvailableClustersResponse(rsp *http.Response) (*ListAvailableClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAvailableClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AvailableCluster
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListBackupRepositoriesResponse parses an HTTP response from a ListBackupRepositoriesWithResponse call
func ParseListBackupRepositoriesResponse(rsp *http.Response) (*ListBackupRepositoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBackupRepositoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []BackupRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBackupRepositoryInfoResponse parses an HTTP response from a GetBackupRepositoryInfoWithResponse call
func ParseGetBackupRepositoryInfoResponse(rsp *http.Response) (*GetBackupRepositoryInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBackupRepositoryInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PgBackrestRepositoryInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListBackupStoresResponse parses an HTTP response from a ListBackupStoresWithResponse call
func ParseListBackupStoresResponse(rsp *http.Response) (*ListBackupStoresResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBackupStoresResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []BackupStore
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBackupStoreResponse parses an HTTP response from a CreateBackupStoreWithResponse call
func ParseCreateBackupStoreResponse(rsp *http.Response) (*CreateBackupStoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBackupStoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BackupStore
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteBackupStoreResponse parses an HTTP response from a DeleteBackupStoreWithResponse call
func ParseDeleteBackupStoreResponse(rsp *http.Response) (*DeleteBackupStoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBackupStoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBackupStoreResponse parses an HTTP response from a GetBackupStoreWithResponse call
func ParseGetBackupStoreResponse(rsp *http.Response) (*GetBackupStoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBackupStoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BackupStore
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListBackupsResponse parses an HTTP response from a ListBackupsWithResponse call
func ParseListBackupsResponse(rsp *http.Response) (*ListBackupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBackupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Backup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteBackupResponse parses an HTTP response from a DeleteBackupWithResponse call
func ParseDeleteBackupResponse(rsp *http.Response) (*DeleteBackupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBackupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBackupResponse parses an HTTP response from a GetBackupWithResponse call
func ParseGetBackupResponse(rsp *http.Response) (*GetBackupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBackupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Backup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBackupLinkResponse parses an HTTP response from a GetBackupLinkWithResponse call
func ParseGetBackupLinkResponse(rsp *http.Response) (*GetBackupLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBackupLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BackupLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListClientsResponse parses an HTTP response from a ListClientsWithResponse call
func ParseListClientsResponse(rsp *http.Response) (*ListClientsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClientsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ApiClient
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateClientResponse parses an HTTP response from a CreateClientWithResponse call
func ParseCreateClientResponse(rsp *http.Response) (*CreateClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiClient
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteClientResponse parses an HTTP response from a DeleteClientWithResponse call
func ParseDeleteClientResponse(rsp *http.Response) (*DeleteClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetClientResponse parses an HTTP response from a GetClientWithResponse call
func ParseGetClientResponse(rsp *http.Response) (*GetClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiClient
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateClientResponse parses an HTTP response from a UpdateClientWithResponse call
func ParseUpdateClientResponse(rsp *http.Response) (*UpdateClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiClient
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListCloudAccountsResponse parses an HTTP response from a ListCloudAccountsWithResponse call
func ParseListCloudAccountsResponse(rsp *http.Response) (*ListCloudAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCloudAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CloudAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateCloudAccountResponse parses an HTTP response from a CreateCloudAccountWithResponse call
func ParseCreateCloudAccountResponse(rsp *http.Response) (*CreateCloudAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCloudAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CloudAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteCloudAccountResponse parses an HTTP response from a DeleteCloudAccountWithResponse call
func ParseDeleteCloudAccountResponse(rsp *http.Response) (*DeleteCloudAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCloudAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCloudAccountResponse parses an HTTP response from a GetCloudAccountWithResponse call
func ParseGetCloudAccountResponse(rsp *http.Response) (*GetCloudAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCloudAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CloudAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListClustersResponse parses an HTTP response from a ListClustersWithResponse call
func ParseListClustersResponse(rsp *http.Response) (*ListClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Cluster
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateClusterResponse parses an HTTP response from a CreateClusterWithResponse call
func ParseCreateClusterResponse(rsp *http.Response) (*CreateClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Cluster
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteClusterResponse parses an HTTP response from a DeleteClusterWithResponse call
func ParseDeleteClusterResponse(rsp *http.Response) (*DeleteClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetClusterResponse parses an HTTP response from a GetClusterWithResponse call
func ParseGetClusterResponse(rsp *http.Response) (*GetClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Cluster
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateClusterResponse parses an HTTP response from a UpdateClusterWithResponse call
func ParseUpdateClusterResponse(rsp *http.Response) (*UpdateClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Cluster
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReadClusterMetricsResponse parses an HTTP response from a ReadClusterMetricsWithResponse call
func ParseReadClusterMetricsResponse(rsp *http.Response) (*ReadClusterMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadClusterMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Metrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListClusterNodesResponse parses an HTTP response from a ListClusterNodesWithResponse call
func ParseListClusterNodesResponse(rsp *http.Response) (*ListClusterNodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClusterNodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ClusterNode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetClusterLogsResponse parses an HTTP response from a GetClusterLogsWithResponse call
func ParseGetClusterLogsResponse(rsp *http.Response) (*GetClusterLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ClusterNodeLogMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListClusterSharesResponse parses an HTTP response from a ListClusterSharesWithResponse call
func ParseListClusterSharesResponse(rsp *http.Response) (*ListClusterSharesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClusterSharesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ClusterShare
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateClusterShareResponse parses an HTTP response from a CreateClusterShareWithResponse call
func ParseCreateClusterShareResponse(rsp *http.Response) (*CreateClusterShareResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClusterShareResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterShare
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteClusterShareResponse parses an HTTP response from a DeleteClusterShareWithResponse call
func ParseDeleteClusterShareResponse(rsp *http.Response) (*DeleteClusterShareResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClusterShareResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReadClusterShareResponse parses an HTTP response from a ReadClusterShareWithResponse call
func ParseReadClusterShareResponse(rsp *http.Response) (*ReadClusterShareResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadClusterShareResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterShare
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListConfigVersionsResponse parses an HTTP response from a ListConfigVersionsWithResponse call
func ParseListConfigVersionsResponse(rsp *http.Response) (*ListConfigVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListConfigVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ConfigVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetConfigVersionResponse parses an HTTP response from a GetConfigVersionWithResponse call
func ParseGetConfigVersionResponse(rsp *http.Response) (*GetConfigVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConfigVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListDatabasesResponse parses an HTTP response from a ListDatabasesWithResponse call
func ParseListDatabasesResponse(rsp *http.Response) (*ListDatabasesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDatabasesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Database
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateDatabaseResponse parses an HTTP response from a CreateDatabaseWithResponse call
func ParseCreateDatabaseResponse(rsp *http.Response) (*CreateDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Database
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteDatabaseResponse parses an HTTP response from a DeleteDatabaseWithResponse call
func ParseDeleteDatabaseResponse(rsp *http.Response) (*DeleteDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDatabaseResponse parses an HTTP response from a GetDatabaseWithResponse call
func ParseGetDatabaseResponse(rsp *http.Response) (*GetDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Database
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateDatabaseResponse parses an HTTP response from a UpdateDatabaseWithResponse call
func ParseUpdateDatabaseResponse(rsp *http.Response) (*UpdateDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Database
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseBackupDatabaseResponse parses an HTTP response from a BackupDatabaseWithResponse call
func ParseBackupDatabaseResponse(rsp *http.Response) (*BackupDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BackupDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDatabaseLogsResponse parses an HTTP response from a GetDatabaseLogsWithResponse call
func ParseGetDatabaseLogsResponse(rsp *http.Response) (*GetDatabaseLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDatabaseLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []DatabaseLogsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDatabaseMetricsResponse parses an HTTP response from a GetDatabaseMetricsWithResponse call
func ParseGetDatabaseMetricsResponse(rsp *http.Response) (*GetDatabaseMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDatabaseMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetricSeriesContainer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplicateDatabaseResponse parses an HTTP response from a ReplicateDatabaseWithResponse call
func ParseReplicateDatabaseResponse(rsp *http.Response) (*ReplicateDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplicateDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRestoreDatabaseResponse parses an HTTP response from a RestoreDatabaseWithResponse call
func ParseRestoreDatabaseResponse(rsp *http.Response) (*RestoreDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRotateDatabaseRolePasswordResponse parses an HTTP response from a RotateDatabaseRolePasswordWithResponse call
func ParseRotateDatabaseRolePasswordResponse(rsp *http.Response) (*RotateDatabaseRolePasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RotateDatabaseRolePasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseQueryDatabaseTableResponse parses an HTTP response from a QueryDatabaseTableWithResponse call
func ParseQueryDatabaseTableResponse(rsp *http.Response) (*QueryDatabaseTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryDatabaseTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TableQueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListInvitesResponse parses an HTTP response from a ListInvitesWithResponse call
func ParseListInvitesResponse(rsp *http.Response) (*ListInvitesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInvitesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Invite
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateInviteResponse parses an HTTP response from a CreateInviteWithResponse call
func ParseCreateInviteResponse(rsp *http.Response) (*CreateInviteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateInviteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Invite
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteInviteResponse parses an HTTP response from a DeleteInviteWithResponse call
func ParseDeleteInviteResponse(rsp *http.Response) (*DeleteInviteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInviteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetInviteResponse parses an HTTP response from a GetInviteWithResponse call
func ParseGetInviteResponse(rsp *http.Response) (*GetInviteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInviteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Invite
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAcceptInviteResponse parses an HTTP response from a AcceptInviteWithResponse call
func ParseAcceptInviteResponse(rsp *http.Response) (*AcceptInviteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AcceptInviteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListMembershipsResponse parses an HTTP response from a ListMembershipsWithResponse call
func ParseListMembershipsResponse(rsp *http.Response) (*ListMembershipsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMembershipsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Membership
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteMembershipResponse parses an HTTP response from a DeleteMembershipWithResponse call
func ParseDeleteMembershipResponse(rsp *http.Response) (*DeleteMembershipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMembershipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGenerateAccessTokenResponse parses an HTTP response from a GenerateAccessTokenWithResponse call
func ParseGenerateAccessTokenResponse(rsp *http.Response) (*GenerateAccessTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateAccessTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccessToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOpenApiSpecResponse parses an HTTP response from a GetOpenApiSpecWithResponse call
func ParseGetOpenApiSpecResponse(rsp *http.Response) (*GetOpenApiSpecResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOpenApiSpecResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OpenApiSpec
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListSshKeysResponse parses an HTTP response from a ListSshKeysWithResponse call
func ParseListSshKeysResponse(rsp *http.Response) (*ListSshKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSshKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SshKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSshKeyResponse parses an HTTP response from a CreateSshKeyWithResponse call
func ParseCreateSshKeyResponse(rsp *http.Response) (*CreateSshKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSshKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SshKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSshKeyResponse parses an HTTP response from a DeleteSshKeyWithResponse call
func ParseDeleteSshKeyResponse(rsp *http.Response) (*DeleteSshKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSshKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSshKeyResponse parses an HTTP response from a GetSshKeyWithResponse call
func ParseGetSshKeyResponse(rsp *http.Response) (*GetSshKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSshKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SshKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListTasksResponse parses an HTTP response from a ListTasksWithResponse call
func ParseListTasksResponse(rsp *http.Response) (*ListTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Task
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCloudFormationTemplateResponse parses an HTTP response from a GetCloudFormationTemplateWithResponse call
func ParseGetCloudFormationTemplateResponse(rsp *http.Response) (*GetCloudFormationTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCloudFormationTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CloudFormationTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListTenantsResponse parses an HTTP response from a ListTenantsWithResponse call
func ParseListTenantsResponse(rsp *http.Response) (*ListTenantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTenantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Tenant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTenantResponse parses an HTTP response from a GetTenantWithResponse call
func ParseGetTenantResponse(rsp *http.Response) (*GetTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Tenant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateTenantResponse parses an HTTP response from a UpdateTenantWithResponse call
func ParseUpdateTenantResponse(rsp *http.Response) (*UpdateTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Tenant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCurrentUserResponse parses an HTTP response from a GetCurrentUserWithResponse call
func ParseGetCurrentUserResponse(rsp *http.Response) (*GetCurrentUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateCurrentUserResponse parses an HTTP response from a UpdateCurrentUserWithResponse call
func ParseUpdateCurrentUserResponse(rsp *http.Response) (*UpdateCurrentUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCurrentUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}
